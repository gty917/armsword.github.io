<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>armsword的涅槃之地</title>
  <meta name="author" content="armsword">
  
  <meta name="description" content="程序员,搜索引擎,网络编程,后台开发,北邮人,阿里巴巴,神马搜索,Linux,C,C++,Python">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="armsword的涅槃之地"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="icon" type="image/x-ico"> 
  <link rel="alternate" href="/atom.xml" title="armsword的涅槃之地" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">armsword的涅槃之地</a></h1>
  <h2><a href="/">莫思身外无穷事，且读生平未见书 || 不为无益之事，何以遣有涯之生</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/about-me">About</a></li>
    
      <li><a href="/document-information">文档资料</a></li>
    
  <li><a href="/atom.xml">RSS</a><li>
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-03-02T08:38:51.000Z"><a href="/2015/03/02/several-realization-of-hash-algorithm/">3月 2 2015</a></time>
      
      
  
    <h1 class="title"><a href="/2015/03/02/several-realization-of-hash-algorithm/">几种Hash算法的实现</a></h1>
  

    </header>
    <div class="entry">
      
        <p>哈希被广泛使用在很多领域，如数据存储，加密，计算机视觉（几何哈希），此处就简单整理下几个常见的Hash函数的实现，有空陆续补充吧。</p>
<h2 id="BKDR_Hash_Function">BKDR Hash Function</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 本算法由于在Brian Kernighan与Dennis Ritchie的《The C Programming Language》一书被展示而得名，是一种简单快捷的<span class="built_in">hash</span>算法。</div><div class="line"></div><div class="line">// 也是Java目前采用的字符串的Hash算法（累乘因子为<span class="number">31</span>）。</div><div class="line"></div><div class="line">// 此哈希函数用的最多</div><div class="line"></div><div class="line">template&lt;class T&gt;</div><div class="line">size_t BKDRHash(const T *str)</div><div class="line">{</div><div class="line">	register size_t <span class="built_in">hash</span> = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span> (size_t ch = (size_t)*str++)</div><div class="line">	{		</div><div class="line">		<span class="built_in">hash</span> = <span class="built_in">hash</span> * <span class="number">131</span> + ch;   // 也可以乘以<span class="number">31</span>、<span class="number">131</span>、<span class="number">1313</span>、<span class="number">13131</span>、<span class="number">131313</span>..</div><div class="line">		// 可将乘法分解为位运算及加减法可以提高效率，如将上式表达为：<span class="built_in">hash</span> = <span class="built_in">hash</span> &lt;&lt; <span class="number">7</span> + <span class="built_in">hash</span> &lt;&lt; <span class="number">1</span> + <span class="built_in">hash</span> + ch;</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> <span class="built_in">hash</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>其中累乘因子也可以为131、1313、13131，比如下述代码就使用了33。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">unsigned <span class="keyword">int</span> times33(<span class="keyword">char</span> *<span class="keyword">str</span>)</div><div class="line">{</div><div class="line">    unsigned <span class="keyword">int</span> val = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (*<span class="keyword">str</span>) </div><div class="line">        val = (val &lt;&lt; <span class="number">5</span>) + val + (*<span class="keyword">str</span>++);</div><div class="line">    <span class="keyword">return</span> val;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>此算法也会有如下变种，如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">unsigned <span class="keyword">int</span> timesnum(<span class="keyword">char</span> *<span class="keyword">str</span>, <span class="keyword">int</span> num)</div><div class="line">{</div><div class="line">    unsigned <span class="keyword">int</span> val = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (*<span class="keyword">str</span>) </div><div class="line">        val = val * num + (*<span class="keyword">str</span>++);</div><div class="line">    <span class="keyword">return</span> val;</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="SDBM_Hash_Function">SDBM Hash Function</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 本算法是由于在开源项目<span class="type">SDBM</span>（一种简单的数据库引擎）中被应用而得名，它与<span class="type">BKDRHash</span>思想一致，只是种子不同而已。</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;class T&gt;</div><div class="line">size_t <span class="type">SDBMHash</span>(<span class="keyword">const</span> T *str)</div><div class="line">{</div><div class="line">	register size_t hash = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span> (size_t ch = (size_t)*str++)</div><div class="line">	{</div><div class="line">		hash = <span class="number">65599</span> * hash + ch;		</div><div class="line">		//hash = (size_t)ch + (hash &lt;&lt; <span class="number">6</span>) + (hash &lt;&lt; <span class="number">16</span>) - hash;</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> hash;</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="AP_Hash_Function">AP Hash Function</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Arash Partow发明的一种hash算法 </span></div><div class="line"><span class="comment">// 比较优秀的一种哈希算法</span></div><div class="line">unsigned <span class="keyword">int</span> APhash(<span class="keyword">char</span> *<span class="keyword">str</span>)</div><div class="line">{</div><div class="line">    unsigned <span class="keyword">int</span> val = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; *<span class="keyword">str</span>; i++) </div><div class="line">        <span class="keyword">if</span> ((i & <span class="number">1</span>) == <span class="number">0</span>)</div><div class="line">            val ^= ((val &lt;&lt; <span class="number">7</span>)^(*<span class="keyword">str</span>++)^(val&gt;&gt;<span class="number">3</span>));</div><div class="line">        <span class="keyword">else</span></div><div class="line">            val ^= (~((val &lt;&lt; <span class="number">11</span>)^(*<span class="keyword">str</span>++)^(val&gt;&gt;<span class="number">5</span>)));</div><div class="line"></div><div class="line">    <span class="keyword">return</span> (val & <span class="number">0x7FFFFFFF</span>);	</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="FNV_Hash_Function">FNV Hash Function</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// <span class="type">Unix</span> system系统中使用的一种著名hash算法，后来微软也在其hash_map中实现。</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;class T&gt;</div><div class="line">size_t <span class="type">FNVHash</span>(<span class="keyword">const</span> T* str)</div><div class="line">{</div><div class="line">	<span class="keyword">if</span>(!*str)</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	register size_t hash = <span class="number">2166136261</span>;</div><div class="line">	<span class="keyword">while</span> (size_t ch = (size_t)*str++)</div><div class="line">	{</div><div class="line">		hash *= <span class="number">16777619</span>;</div><div class="line">		hash ^= ch;</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> hash;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>其实关于为什么要用异或，我搜索了下原因，见<a href="http://stackoverflow.com/questions/5889238/why-is-xor-the-default-way-to-combine-hashes" target="_blank" rel="external">Why is XOR the default way to combine hashes?</a></p>
<h2 id="MySQL中出现的字符串哈希函数">MySQL中出现的字符串哈希函数</h2>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> MySQLhash(<span class="keyword">char</span> *str)</div><div class="line">{</div><div class="line">    <span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> nr = <span class="number">1</span>, nr2 = <span class="number">4</span>;</div><div class="line">    <span class="keyword">while</span>(*str) {</div><div class="line">        nr ^= (((nr & <span class="number">63</span>) + nr2)*((<span class="keyword">unsigned</span> <span class="keyword">int</span>)*str++)) + (nr &lt;&lt; <span class="number">8</span>);</div><div class="line">        nr2 += <span class="number">3</span>;	</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)nr;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>参考链接：<br><a href="https://github.com/armsword/Source/blob/master/spiderq/src/hashs.cpp" target="_blank" rel="external">spiderq</a><br><a href="http://blog.csdn.net/qq7366020/article/details/8730425" target="_blank" rel="external">各种哈希函数冲突率分析</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-01-31T12:39:13.000Z"><a href="/2015/01/31/baidu-lossless-music-downloader/">1月 31 2015</a></time>
      
      
  
    <h1 class="title"><a href="/2015/01/31/baidu-lossless-music-downloader/">写了一个Chrome插件 - 百度无损音乐下载插件</a></h1>
  

    </header>
    <div class="entry">
      
        <p>用了2-3天时间，学了下前端开发方面的基础知识，没怎么看教程，就是想实现某些功能或者遇到问题就去搜索解决，遇到了一些坑，但是收获也挺大的，于是随手写了个Chrome插件，可用来下载百度无损音乐的，比较简单，懒得讲啥原理了，这里只分享下已注释源码和使用方法吧。</p>
<h3 id="程序地址">程序地址</h3>
<p><a href="https://github.com/armsword/BDMusicDownloader/blob/master/BDMusicDownloader.zip?raw=true" target="_blank" rel="external">点击下载插件</a></p>
<h3 id="使用方法">使用方法</h3>
<p>本插件支持Chrome浏览器和UC桌面浏览器，其他Webkit内核的浏览器应该也支持，但是我没做测试。</p>
<h4 id="Linux系统下安装方法">Linux系统下安装方法</h4>
<p>Linux下直接<a href="https://github.com/armsword/BDMusicDownloader/blob/master/BDMusicDownloader.zip?raw=true" target="_blank" rel="external">下载</a>此插件，之后解压后，在BDMusicDownloader文件夹下发现一个src.crx文件，将其拖入到Chrome浏览器-设置-扩展程序界面即可，当打开如以 <a href="http://music.baidu.com/song/" target="_blank" rel="external">http://music.baidu.com/song/</a> 开头的链接时，即下载音乐地址，会自动弹出插件，点击下载即可。如图所示：<br><img src="http://armsword.com/wp-content/uploads/2015/01/20150101.png" alt=""></p>
<h3 id="Windows下安装方法">Windows下安装方法</h3>
<p>从程序地址里下载安装插件，解压文件夹，注意，因为Chrome在Win下的安全限制，所以此文件夹不能删除，之后同上所示，但不是拖入src.crx文件，而是选中开发者模式-加载正在开发的插件-BDMusicDownloader，之后选中src文件，打开即可。如图以UC桌面浏览器为例：<br><img src="http://armsword.com/wp-content/uploads/2015/01/20150102.jpg" alt=""></p>
<p>说句题外话，UC桌面浏览器真的还蛮好用的，支持Chrome插件（废话，使用的都是同一个内核），但是自带科学上网，打开Github速度就挺快的，推荐使用。</p>
<h3 id="需要改进的地方">需要改进的地方</h3>
<p>因为我前端经验太少，所以一些小细节没处理好，比如当音乐名字太长时，样式就比较难看了。因我忙着在回家前要把孙钟秀的《操作系统教程》读完，并且之前部门给我的入职前作业我还没完成，所以不打算再做太多修改了，感兴趣的东西可以帮忙修改下。</p>
<h2 id="源码地址">源码地址</h2>
<p><a href="https://github.com/armsword/BDMusicDownloader" target="_blank" rel="external">https://github.com/armsword/BDMusicDownloader</a></p>
<p>代码已注释，有时间和感兴趣的同学，可以帮忙优化下界面。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-01-26T05:50:48.000Z"><a href="/2015/01/26/jwsmtp-analyse/">1月 26 2015</a></time>
      
      
  
    <h1 class="title"><a href="/2015/01/26/jwsmtp-analyse/">jwSMTP源码剖析</a></h1>
  

    </header>
    <div class="entry">
      
        <p>前段时间事情太多了，忙着写毕业论文，考试，然后又被抽到了盲审，不过好在有惊无险，最后也在学院提交三月中旬申请答辩成功，如果盲审顺利的话，4月份就可以毕业了。不过这段时间总算可以看代码、看书了，感觉自己操作系统方面有些不扎实，索性买了本孙钟秀的《操作系统教程》看，之后顺便阅读和分析了jwSMTP源码，这里写篇文章记录下。本文不想对代码细节作太多分析，因为代码比较好读，并且文章末尾我会放出我注释过的源码链接，所以此文多介绍下原理吧。</p>
<h2 id="jwSMTP">jwSMTP</h2>
<p>jwSMTP是一个由C++编写的发送邮件的库，支持Linux、Windows等平台。可使用HTML或纯文本方式发送邮件。也可添加附件，支持多个收件人。并且支持LOGIN和PLAIN两种服务器验证方式。</p>
<h2 id="两种调用方式">两种调用方式</h2>
<h3 id="第一种方式">第一种方式</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mailer mail(“myfriend<span class="keyword">@friend</span>.com”, <span class="comment">// who the mail is too</span></div><div class="line">“someone<span class="keyword">@somewhere</span>.net”, <span class="comment">// who the mail is from</span></div><div class="line">“There <span class="keyword">is</span> always room <span class="keyword">for</span> FooBar”, <span class="comment">// subject for the email</span></div><div class="line">“Foo\nBar”, <span class="comment">// content of the message</span></div><div class="line">“ns.somewhere.net”); <span class="comment">// the nameserver to contact</span></div><div class="line"><span class="comment">// to query for an MX record</span></div><div class="line">mail.send( );</div></pre></td></tr></table></figure>

<h3 id="第二种方式">第二种方式</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mailer mail(“myfriend<span class="keyword">@friend</span>.com”, <span class="comment">// who the mail is too</span></div><div class="line">“someone<span class="keyword">@somewhere</span>.net”, <span class="comment">// who the mail is from</span></div><div class="line">“There <span class="keyword">is</span> always room <span class="keyword">for</span> FooBar”, <span class="comment">// subject for the email</span></div><div class="line">vec, <span class="comment">// content of the message</span></div><div class="line">“mail.somewhere.net”, <span class="comment">// the smtp server to mail to</span></div><div class="line">mailer::SMTP_PORT, <span class="comment">// default smtp port (25)</span></div><div class="line"><span class="literal">false</span>); <span class="comment">// do not query MX records,</span></div><div class="line"><span class="comment">// mail directly to mail.somewhere.net</span></div></pre></td></tr></table></figure>

<p>主要区别是一个查询MX record，一个不查询MX record，直接发送给SMTP Server。</p>
<h2 id="base64编码">base64编码</h2>
<p>Base64是网络上最常见的用于传输8Bit字节代码的编码方式之一，设计此种编码是为了使二进制数据可以通过非纯8bit的传输层传输，Base64编码可用于在HTTP环境下传递较长的标识信息，另一方面，采用Base64编码具有不可读性，即所编码的数据不会被人用肉眼所直接看到。<br>电子邮件的主题，MIME都会用到base64编码。我们现在说下其原理：</p>
<p>Base64编码方法：</p>
<ul>
<li>base64的编码都是按字符串长度，以每3个8bit的字符为一组，然后针对每组，首先获取每个字符的ASCII编码，然后将ASCII编码转换成8bit的二进制，得到一组3*8=24bit的字节，然后再将这24bit划分为4个6bit的字节，并在每个6bit的字节前面都填两个高位0，得到4个8bit的字节，然后将这4个8bit的字节转换成10进制，对照Base64编码表，得到对应编码后的字符。</li>
<li>不是3的整数倍的，需要补齐而出现的0，转化成十进制的时候就不能按常规用base64编码表来对应，可以理解成为一种特殊的“异常”，编码应该对应“=”。<br>代码base64.cpp/base64.h是对Base64编码的实现，更多原理请参考下参考链接关于base64编码的原理与实现一文。打开一封Email，查看其原始信息，一般为如下所示：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="label">Date:</span> Thu, <span class="number">25</span> <span class="keyword">Dec</span> <span class="number">2014</span> <span class="number">06</span>:<span class="number">33</span>:<span class="number">07</span> +<span class="number">0800</span> </div><div class="line"><span class="label">From:</span> A&lt;A@yeah.net&gt;</div><div class="line"><span class="label">To:</span> <span class="string">"B"</span>&lt;b<span class="localvars">@126</span>.com&gt; </div><div class="line"><span class="label">Subject:</span> </div><div class="line"><span class="built_in">X</span>-mailer: Foxmail <span class="number">5.0</span> beta2 [cn] </div><div class="line">Mime-Version: <span class="number">1.0</span> </div><div class="line">Content-Type: text/plain<span class="comment">; </span></div><div class="line">charset=<span class="string">"gb2312"</span> </div><div class="line">Content-Transfer-Encoding: base64 </div><div class="line"></div><div class="line">xOO6w6OsU25haVgNCg0KoaGhodXiysfSu7j2QmFzZTY0tcSy4srU08q8/qOhDQoNCkJlc3QgV2lz </div><div class="line">aGVzIQ0KIAkJCQkNCqGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaEgICAgICAgICAgICAgICBl </div><div class="line">U1g/IQ0KoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoSAgICAgICAgICAgICAgIHNuYWl4QHll </div><div class="line">YWgubmV0DQqhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhICAgICAgICAgMjAwMy0x </div><div class="line">Mi0yNQ0K</div></pre></td></tr></table></figure>

<h2 id="程序流程">程序流程</h2>
<p>程序一般为先设置发件人信息，之后设置收件人信息，对应的函数为setsender()和addrecipient()函数，此处没什么可说的。之后是setmessage/setmessageHTML函数，两者的主要区别是不是需要base64编码，方法前面已说，此处主要说下checkRFCcompat()函数，此函数主要功能是：将消息结尾改为CRLF（\r\n）形式，之后注意此处：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(message.size() == <span class="number">1</span>) {</div><div class="line">   <span class="keyword">if</span>(*(message.<span class="keyword">begin</span>()) == <span class="string">'.'</span>)</div><div class="line">      message.push_back(<span class="string">'.'</span>);</div><div class="line">}</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(message.size() == <span class="number">2</span>) {</div><div class="line">   <span class="keyword">if</span>(*(message.<span class="keyword">begin</span>()) == <span class="string">'.'</span>) {</div><div class="line">      it = message.<span class="keyword">begin</span>();</div><div class="line">      it = message.insert(it, <span class="string">'.'</span>);</div><div class="line">   }</div><div class="line">}</div><div class="line"><span class="keyword">else</span> {</div><div class="line">   <span class="keyword">if</span>(*(message.<span class="keyword">begin</span>()) == <span class="string">'.'</span>) {         </div><div class="line">      it = message.<span class="keyword">begin</span>();</div><div class="line">      it = message.insert(it, <span class="string">'.'</span>);</div><div class="line">   }</div><div class="line">   <span class="keyword">for</span>(it = message.<span class="keyword">begin</span>()+<span class="number">2</span>; it != message.<span class="keyword">end</span>(); ++it) {</div><div class="line">      <span class="regexp">//</span> follow the rfc. <span class="constant">Add</span> <span class="string">'.'</span> <span class="keyword">if</span> the first character on a line is <span class="string">'.'</span></div><div class="line">      <span class="keyword">if</span>(*it == <span class="string">'\n'</span>) {</div><div class="line">         <span class="keyword">if</span>( ((it + <span class="number">1</span>) != message.<span class="keyword">end</span>()) && (*(it +<span class="number">1</span>) == <span class="string">'.'</span>) ) {</div><div class="line">            it = message.insert(it + <span class="number">1</span>, <span class="string">'.'</span>);</div><div class="line">            ++it; <span class="regexp">//</span> step past</div><div class="line">         }</div><div class="line">      }</div><div class="line">   }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>此处是根据<a href="https://www.ietf.org/rfc/rfc2821.txt" target="_blank" rel="external">RFC2821</a>（SMTP协议）的4.5.2 Transparency编写的，内容为下：</p>
<ol>
<li><p>Before sending a line of mail text, the SMTP client checks the first character of the line.  If it is a period, one additional period is inserted at the beginning of the line.</p>
</li>
<li><p>When a line of mail text is received by the SMTP server, it checks the line.  If the line is composed of a single period, it is treated as the end of mail indicator.  If the first character is a period and there are other characters on the line, the first character is deleted.</p>
</li>
</ol>
<p>然后就是每一行消息不能超过1000个字符，见RFC2821的text line小节。</p>
<p>之后的一些setsubject、setserver、addrecipent等等函数，都不做解释了，都是用来添加/删除主机、设置服务器、增加/删除收件人列表相关的，很好明白。我们重点说下邮件发送函数send()里的operator()()函数，如果lookupMXRecord为真，就调用gethostaddresses()函数，用来查询MX记录，这涉及到DNS协议相关知识，请查DNS小节。如果为fasle，则直接连接SMTP server，operator()()和makesmtpmessage()函数主要是完成了如下流程（并不完全一致，仅参考）：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">C： telnet smtp.163.com 25 （连接到163的SMTP服务器，协议规定SMTP服务器的端口号为25）</div><div class="line">S： Trying 202.108.5.83...</div><div class="line">    Connected to smtp.163.split.netease.com.</div><div class="line">    Escape character is '^]'.</div><div class="line">    220 163.com Anti-spam GT for Coremail System (163com[071018]) （220 表示连接成功）</div><div class="line">C： HELO smtp.163.com （协议规定的握手过程，格式为HELO + 服务器名称）</div><div class="line">S： 250 OK （250 表示握手成功）</div><div class="line">C： AUTH LOGIN （AUTH LOGIN 是用户登录命令）</div><div class="line">S: 334 dXNlcm5hbWU6 （334表示服务器接受）</div><div class="line">C： tommy_mail （输入明文用户名）</div><div class="line">S： 535 Error: authentication failed （服务器拒绝，因为SMTP要求用户名和密码都通过64位编码后再发送）</div><div class="line">C： AUTH LOGIN （重新要求SMTP登录）</div><div class="line">S: 334 dXNlcm5hbWU6 </div><div class="line">C: dG9tb<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>FpbA== （用编码后的内容发送）</div><div class="line">S： 334 UGFzc3dvcmQ6 （334表示接受）</div><div class="line">C： <span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>aXZldXA= （编码后的密码）</div><div class="line">S： 235 Authentication successful （235 登录成功）</div><div class="line">C： MAIL FROM:<span class="variable">&lt;A@163.com&gt;</span> （MAIL FROM：<span class="variable">&lt;&gt;</span>格式，用来记录发送者）</div><div class="line">S： 250 Mail OK （250 系统常用确认信息）</div><div class="line">C： RCPT TO:<span class="variable">&lt;B@126.com&gt;</span> （接收者邮箱，可多次使用以实现发送给多个人）</div><div class="line">S： 250 Mail OK</div><div class="line">C： DATA （DATA明令表示以下为邮件正文）</div><div class="line">S： 354 End data with <span class="variable">&lt;CR&gt;</span><span class="variable">&lt;LF&gt;</span>.<span class="variable">&lt;CR&gt;</span><span class="variable">&lt;LF&gt;</span></div><div class="line">C： TO:11<span class="comment">@11 （发送给谁，这里可自由撰写，也是伪造邮件的一个入口，欺骗一般人可以，但会读源码的人欺骗不了）</span></div><div class="line">FROM:22<span class="comment">@22 （发送者是谁，可串改）</span></div><div class="line">SUBJECT:TEST MAIL SMTP （邮件主题）</div><div class="line">             </div><div class="line">hello world （空一行写邮件正文）</div><div class="line">. （正文以.结束）</div><div class="line">S： 250 Mail OK queued as smtp3,DdGowLBLAjqD6_JIg1hfBA==.63235S2 1223879684 （服务器接受）</div><div class="line">C： noop （空操作，延迟退出时间）</div><div class="line">S： 250 OK</div><div class="line">C： quit （退出SMTP服务器连接）</div><div class="line">S： 221 Bye</div></pre></td></tr></table></figure>

<h2 id="DNS协议">DNS协议</h2>
<p>调用gethostaddresses()函数，用来查询MX记录，这涉及到DNS协议相关知识，本函数可以使用nslookup命令模拟，我本地模拟如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">imlinuxer@imlinuxer:~$ nslookup </div><div class="line">&gt; set <span class="variable">type=</span>mx</div><div class="line">&gt; mail.qq.com</div><div class="line">Server:		<span class="number">127.0</span>.<span class="number">1.1</span></div><div class="line">Address:	<span class="number">127.0</span>.<span class="number">1.1</span><span class="comment">#53</span></div><div class="line"></div><div class="line">Non-authoritative answer:</div><div class="line">*** Can't find mail.qq.com: No answer</div><div class="line"></div><div class="line">Authoritative answers can be found from:</div><div class="line">mail.qq.com</div><div class="line">	<span class="variable">origin =</span> qq.com</div><div class="line">	mail <span class="variable">addr =</span> webmaster.qq.com</div><div class="line">	<span class="variable">serial =</span> <span class="number">1186990741</span></div><div class="line">	<span class="variable">refresh =</span> <span class="number">300</span></div><div class="line">	<span class="variable">retry =</span> <span class="number">600</span></div><div class="line">	<span class="variable">expire =</span> <span class="number">86400</span></div><div class="line">	<span class="variable">minimum =</span> <span class="number">86400</span></div></pre></td></tr></table></figure>

<p>DNS查询的过程一般是：客户向DNS服务器的53端口发送UDP报文，DNS服务器收到后进行处理，并把结果记录仍以UDP报文的形式返回过来。除了报文头是固定的12字节外，其他每一部分的长度均为不定字节数。我们只关心的是报文头、问题、回答这三个部分<br>DNS的协议为<a href="http://www.ietf.org/rfc/rfc1035.txt" target="_blank" rel="external">rfc1035</a>，但是枯燥难懂，可以查看参考链接的DNS消息格式，比较容易理解。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> dns[<span class="number">512</span>] = {<span class="number">1</span>,<span class="number">1</span>,   <span class="number">1</span>,<span class="number">0</span>,      <span class="number">0</span>,<span class="number">1</span>,      <span class="number">0</span>,<span class="number">0</span>, <span class="number">0</span>,<span class="number">0</span>, <span class="number">0</span>,<span class="number">0</span>};</div></pre></td></tr></table></figure>

<p>比如此处即为DNS Header消息头部信息。<br>之后几段代码是请求部分格式，代码里我已详细注释，之后发送请求，解析应答即可。</p>
<h2 id="SMTP验证方式">SMTP验证方式</h2>
<p>比较简单，原理见此：<a href="http://blog.csdn.net/mhfh611/article/details/9470599" target="_blank" rel="external">SMTP验证方式种类（LOGIN、PLAIN、CRAM-MD5）</a><br>jwSMTP代码只实现了两种验证方式：LOGIN和PLAIN。</p>
<p>说的有点多了，感觉很多原理都解释了，逻辑稍微有一点混乱，主要是自己不是那么擅长组织语言，如果读者有兴趣，可以多了解下原理，知道SMTP和DNS原理，基本上代码就不需要多看了。</p>
<p>最后扔出我的中文源码剖析代码，在Github上：</p>
<p><a href="https://github.com/armsword/Source/tree/master/jwSMTP" target="_blank" rel="external">https://github.com/armsword/Source/tree/master/jwSMTP</a></p>
<h2 id="参考链接">参考链接</h2>
<p><a href="http://www.cnblogs.com/hongru/archive/2012/01/14/2321397.html" target="_blank" rel="external">关于base64编码的原理与实现</a><br><a href="http://blog.csdn.net/zhangchaomao1987528/article/details/8719733" target="_blank" rel="external">POP3 SMTP协议分析学习笔记</a><br><a href="http://www.cnblogs.com/cobbliu/archive/2013/04/02/2996333.html" target="_blank" rel="external">DNS消息格式</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-12-01T09:17:49.000Z"><a href="/2014/12/01/learn-emacs-note/">12月 1 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/12/01/learn-emacs-note/">Emacs学习笔记</a></h1>
  

    </header>
    <div class="entry">
      
        <p>团队师兄给我说，我们团队统一使用Emacs编程，因为那边是结对编程，所以作为一枚Emacs门外汉，还是需要在明年入职前，熟悉下Emacs的基本操作的，今天折腾了一小会，感觉要比Vim复杂好多，并且总是感觉自己手不够大，命令也要比Vim难记住，索性写篇笔记记录下吧。</p>
<h2 id="安装Emacs">安装Emacs</h2>
<p>Ubuntu已支持最新版本，命令直接安装即可：</p>
<pre><code><span class="built_in">sudo</span> apt-get install emacs
</code></pre><p>即可成功安装，目前是GNU Emacs 24.3.1版本。</p>
<h2 id="熟悉快捷键">熟悉快捷键</h2>
<p>在Emacs的快捷键中，C表示Ctrl键，M表示Alt键，快捷键C-x C-f代表的含义就是：<br>先按下Ctrl不放，然后按下x键；接着放手，再按下Ctrl键不放，最后按下f键。启动后会看到一个欢迎界面，按q关闭它即可进入普通编辑器模式。</p>
<p>常用的快捷键如下所示：</p>
<ul>
<li><strong>新建文件</strong>：C-x C-f</li>
<li><strong>保存文件</strong>：C-x C-s</li>
<li><strong>退出文件</strong>：C-x C-c</li>
<li><strong>选中</strong>：C-@</li>
<li><strong>复制</strong>：M-w</li>
<li><strong>剪切</strong>：C-w</li>
<li><strong>粘贴</strong>：C-y</li>
<li><strong>撤销</strong>：C-x u</li>
<li><strong>删除一行</strong>：C-k</li>
<li><strong>搜索</strong>：向前搜索 C-s，向后搜索 C-r</li>
<li><strong>上移</strong>：C-p</li>
<li><strong>下移</strong>：C-n</li>
<li><strong>左移</strong>：C-b</li>
<li><strong>下移</strong>：C-f</li>
<li><strong>移动到行首</strong>：C-a</li>
<li><strong>移动到行尾</strong>：C-e</li>
<li><strong>切换Buffer</strong>：C-x b</li>
<li><strong>显示Buffer列表</strong>：C-x C-b</li>
<li><strong>跳转到最后一行</strong>：C-End</li>
<li><strong>跳转到第一行</strong>：C-Home</li>
</ul>
<p>跳转到指定行我自己定义了M-x快捷键。</p>
<p>为了阅读源代码，安装了Global插件</p>
<pre><code>sudo apt-<span class="built_in">get</span> install <span class="keyword">global</span>
</code></pre><p>使用gtags命令，生成4个文件，快捷键为：</p>
<ul>
<li><strong>跳转到符号定义</strong>：M-x.</li>
<li><strong>回到之前位置</strong>：M-*</li>
</ul>
<p>最后吐槽下，Emacs好难用，如果不是部门强制使用的话，我才不会学这么复杂的编辑器呢，我感觉Vim入门更快些，并且Sublime也不错，推荐使用，人生苦短，何必为了学习编辑器的使用而浪费时间呢。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-11-22T13:30:51.000Z"><a href="/2014/11/22/move-from-wordpress-to-hexo/">11月 22 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/11/22/move-from-wordpress-to-hexo/">将WordPress迁移到hexo并同时托管到Github和Gitcafe上</a></h1>
  

    </header>
    <div class="entry">
      
        <p>租了两年多的服务器要过期了，不打算续费了，于是就研究了下将博客从WordPress迁移到静态博客上，后来选择了hexo静态博客，node.js编写，并且同时使用Github和Gitcafe托管博客。</p>
<p>在迁移过程中，删除了部分难修改且目前无意义的博客，并且链接我也没改成与之前一样，就这样吧，反正我也不在乎流量，就当个记事本用。</p>
<p>这里简单记录下将WordPress迁移到静态博客和将博客同时托管到Github和Gitcafe过程。</p>
<ul>
<li>Ubuntu下安装node.js</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo apt-<span class="built_in">get</span> <span class="keyword">update</span></div><div class="line">sudo apt-<span class="built_in">get</span> install -<span class="keyword">y</span> <span class="keyword">python</span>-software-properties software-properties-common</div><div class="line">sudo <span class="built_in">add</span>-apt-repository <span class="keyword">pp</span><span class="variable">a:chris</span>-lea/node.js</div><div class="line">sudo apt-<span class="built_in">get</span> <span class="keyword">update</span></div><div class="line">sudo apt-<span class="built_in">get</span> install nodejs</div></pre></td></tr></table></figure>

<ul>
<li>安装hexo</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="operator"><span class="keyword">install</span> -g hexo</span></div></pre></td></tr></table></figure>

<ul>
<li>创建hexo文件夹</li>
</ul>
<p>随便找个文件夹，之后执行以下命令，hexo会自动在该目标文件夹下建立网站所需要的所有文件。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo <span class="keyword">init</span></div></pre></td></tr></table></figure>

<ul>
<li>安装依赖包</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="operator"><span class="keyword">install</span></span></div></pre></td></tr></table></figure>

<p>执行以下命令，在浏览器输入localhost:4000查看</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo generate</div><div class="line">hexo <span class="keyword">server</span></div></pre></td></tr></table></figure>

<h2 id="将博客从wordPress迁移到hexo中">将博客从wordPress迁移到hexo中</h2>
<ul>
<li>安装WordPress Migrator插件</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="operator"><span class="keyword">install</span> hexo-migrator-wordpress <span class="comment">--save</span></span></div></pre></td></tr></table></figure>

<ul>
<li><p>导出文章<br>登录WordPress管理控制台，选择工具-&gt;导出，再选择文章。点击下载导出的文件，就可以得到一个名称类似wordpress.2014-11-23.xml的文件 </p>
</li>
<li><p>将文章导入到hexo<br>在hexo根目录下，执行以下命令，导入文章</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo migrate wordpress <span class="number">2014</span><span class="subst">-</span><span class="number">11</span><span class="subst">-</span><span class="number">23.</span><span class="built_in">xml</span> <span class="comment">// 2014-11-23.xml为导出文章的XML</span></div></pre></td></tr></table></figure>

<p>之后再简单修改下_POST文件各文章的md格式就可以了。</p>
<p>详情，我就不做多做解析了，网上有很多详细的攻略，可以查看我的参考链接里那篇文章吧。</p>
<p>然后同时部署到github和gitcafe上，方法如下：<br>编辑_config.yml文件，将deploy改为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">    type: git</div><div class="line">    repo:</div><div class="line">        github: git@<span class="filename">github.com</span>:armsword/<span class="filename">armsword.github.io.git,master        </span></div><div class="line">        gitcafe: git@<span class="filename">gitcafe.com</span>:armsword/<span class="filename">armsword.git,gitcafe-pages</span></div></pre></td></tr></table></figure>

<p>同时删除目录下的 .deploy 文件，之后hexo deploy 即可。<br>当然之后还需要去DnsPod做下DNS解析。</p>
<p>最后一张博客流量图，纪念我那逝去的WordPress：</p>
<p><img src="http://armsword.com/wp-content/uploads/2014/11/traffic.png" alt=""></p>
<h2 id="参考链接：">参考链接：</h2>
<p><a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">hexo搭建博客教程</a><br><a href="http://dlutwuwei.github.io/2014/05/20/hexo%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/" target="_blank" rel="external">hexo博客去掉google字体</a><br><a href="https://gitcafe.com/GitCafe/Help/wiki/Pages-%E7%9B%B8%E5%85%B3%E5%B8%AE%E5%8A%A9" target="_blank" rel="external">gitcafe搭建过程</a><br><a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">deployment</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-11-07T08:40:56.000Z"><a href="/2014/11/07/finding-job-result/">11月 7 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/11/07/finding-job-result/">一蓑烟雨任平生</a></h1>
  

    </header>
    <div class="entry">
      
        <p>决定去阿里巴巴了，神马搜索部门，工作地点在杭州西湖区，是我比较满意的结果，所以今天索性签了阿里巴巴，三方也交了出去，校招总算划了个句号。</p>
<p>来北邮读研，我的目标就是找一份好的工作，要去互联网发展。所以，研究生期间并为之努力。很长一段时间里，我的Dream Offer是微软苏州，当时的想法是苏州离我家近一些，后来微软裁员，苏州STC不怎么招人，我就比较愁，难道要留京吗，我个人不是太喜欢北京的环境的。因为我阿里朋友比较多，平常大家也会交流下技术以及公司的一些情况，我对阿里是比较有好感的，阿里的朋友也经常说，我技能树与阿里的一些部门非常相似，来阿里会更好一些，于是我就决定校招我要去阿里巴巴。后来微软校招我都没参加笔试。</p>
<p>其实从校招实习面试开始到我签阿里，这半年多时间里，我一共面过四家公司（我怕拿到Offer不去，不厚道，就没怎么投），估计是北邮所有学生里面试公司最少的了，汗！在七月份的时候，我决定把阿里巴巴当作自己的校招目标，于是在九月下旬拿到阿里的Offer后，我就决定去阿里了，之后拒掉了所有其他公司的面试和笔试，大部分时间就是帮同学解答问题和帮他们找找内推等等，目前身边的小伙伴都还算找到了自己满意的工作，我也很替他们高兴。</p>
<p>其实，《数学之美》这本书应该是研究生期间影响我最大的一本书吧，我决定投搜索岗完全是这本书勾引的，虽然我技能会的都是Linux C/C++后台开发，在搜索方面并没多少经验，因为当时我认为，Linux C/C++ 都没学好，就别搞那些高大上的机器学习，搜索算法了。不会这些，这也让我面试时候很被动，今后几个月的学生生涯，我也得努力补回来。</p>
<p>九月份时候联系过神马的人力周老师，他帮我推过一次神马搜索，但是毕竟当时自己水平有限，也没有多少面试经验，电面了一小时后，第二天我就被刷掉了。于是参加了阿里的正规校招，面试最后一天，我重感冒，嗓子也说不出来话，但各种机缘巧合吧，四面技术面+一次HR面，幸运的拿到了阿里Offer，但是虽然面的研发，职位确变成了安全工程师，主要是当时是安全部面试官面试的我，我也被分到了安全部。我虽然略懂些安全，但我不想从事这个行业，我也给安全部HR说了，想做广告反作弊，但是我怕万一到时候被分到做入侵检测这块，于是我给张老师发了封邮件，说了自己想去神马搜索的想法，张老师给杭州那边的神马搜索的负责人转发了我的意愿，几天后，周老师就通知我，我成功去了神马搜索，核心引擎小团队，我喜欢的部门之一。</p>
<p>这里感谢校招期间帮助过我的所有人，特别感谢周向荣老师，您为我争取了面试机会，但很抱歉，我逃出了你们部门。感谢周正炎老师给了我一次神马搜索的面试机会并且交待我在校期间好好准备搜索相关知识，以后入职估计还会麻烦你，感谢张栋老师帮我转到了神马搜索，同时也感谢杭州那边神马搜索的Boss们收留我。</p>
<p>有人说，如果你对某一方向感兴趣，有两种选择：</p>
<p>第一种选择，是进入这个行业，但选择领先者，以实践自己的聪明才智。<br>第二种选择，是进入这个行业，但选择挑战者，以见证奇迹的诞生。</p>
<p>我选择了后者，既然选择了，便只顾风雨兼程，无论怎么样，我也不会后悔今天的选择，一蓑烟雨任平生。</p>
<p>&nbsp;</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-10-28T16:46:18.000Z"><a href="/2014/10/29/tinyhttpd-code-analyse/">10月 29 2014</a></time>
      
      
  
    <h1 class="title"><a href="/2014/10/29/tinyhttpd-code-analyse/">tinyhttpd源码剖析</a></h1>
  

    </header>
    <div class="entry">
      
        <p>喊了几天学习Web开发，为了毕业论文，今晚上计划也是看看CSS呢，但是实在是没忍住，读了下经典的tinyhttp的源代码，这款代码还是颇有名气的，网上这么评论的：</p>
<blockquote>
<p>tinyhttpd是一个超轻量型Http Server，使用C语言开发，全部代码只有500、600行，附带一个简单的Client，可以通过阅读这段代码理解一个Http Server的本质。</p>
</blockquote>
<p>其实，代码颇简单，适合刚学习Web Server的童鞋学习，因为我之前写过CGI Server，所以，我还是认为此代码写的一般，并且我在Ubuntu下编译遇到了不少错误，我都懒得写详细分析了，所以随便写下吧，后面的Github地址里有详细的分析。</p>
<p>源码下载地址：<a href="http://sourceforge.net/projects/tinyhttpd/" title="tinyhttpd源码分析" target="_blank" rel="external">http://sourceforge.net/projects/tinyhttpd/</a></p>
<p>make编译后会有不少错误和警告，我这里说下怎么改正错误：</p>
<p>1、Makefile文件里的：gcc -W -Wall -lsocket -lpthread -o httpd httpd.c ，修改为：</p>
<p>gcc -W -Wall -o httpd httpd.c -lpthread</p>
<p>2、481行的 int client_name_len 改为 socklen_t client_name_len</p>
<p>3、436行 改动与上面相似，改为socklen_t类型即可。</p>
<p>4、34行改为void <em>accept_request(void </em>);  所以下面的实现也要修改下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> *accept_request(<span class="keyword">void</span>* client1)</div><div class="line">{</div><div class="line"><span class="keyword">int</span> client = *(<span class="keyword">int</span> *)client1;</div><div class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</div><div class="line"></div><div class="line"><span class="comment">// 省略</span></div><div class="line"></div><div class="line">同时注意此函数<span class="number">77</span> 和<span class="number">129</span>行改为<span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line"></div><div class="line"><span class="number">497</span>行改为<span class="keyword">if</span> (pthread_create(&amp;newthread , <span class="keyword">NULL</span>, accept_request, (<span class="keyword">void</span>*)client_sock) != <span class="number">0</span>)</div></pre></td></tr></table></figure>

<p>之后再make，程序就OK了。</p>
<p>简单说下程序的逻辑吧：</p>
<p>一个无限循环，一个请求，创建一个线程，之后线程处理函数处理每个请求，然后解析HTTP请求，然后做一些判断处理，之后判断文件是否可执行，不可执行，打开文件，输出给客户端（浏览器）呗，可执行就创建管道，父子进程通信。</p>
<p>整个流程就这么简单，程序主要处理2种HTTP请求方式：GET和POST，懒得说了，上传两张图片，自己分析吧，图片原始出处不清楚，电脑里存了好久了,。</p>
<p>GET：</p>
<p><img src="http://armsword.com/wp-content/uploads/2014/10/2014102901.png" alt=""></p>
<p>POST：</p>
<p><img src="http://armsword.com/wp-content/uploads/2014/10/2014102902.png" alt=""></p>
<p>&nbsp;</p>
<p>其实这个源码里有一个地方比较难懂，就是那个解析HTTP每一行的那个get_line函数里的recv的MSG_PEEK参数，详细解释可以参考此<a href="http://www.blogbus.com/gcoder-logs/220779725.html" target="_blank" rel="external">链接</a>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 读取socket，判断换行，CRLF标志，之后以"\n"换行，并在字符串后添加'\0'</span></div><div class="line"><span class="keyword">int</span> get_line(<span class="keyword">int</span> sock, <span class="keyword">char</span> *buf, <span class="keyword">int</span> <span class="keyword">size</span>)</div><div class="line">{</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">char</span> c = <span class="string">'&#92;&#48;'</span>;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> ((i &lt; <span class="keyword">size</span> - <span class="number">1</span>) &amp;&amp; (c != <span class="string">'\n'</span>))</div><div class="line">    {</div><div class="line">        <span class="comment">// 一个字符一个字符的读取</span></div><div class="line">        n = recv(sock, &c, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">         <span class="comment">/* DEBUG printf("%02X\n", c); */</span></div><div class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</div><div class="line">        {</div><div class="line">            <span class="keyword">if</span> (c == <span class="string">'\r'</span>)</div><div class="line">            {</div><div class="line">                <span class="comment">/*</span></div><div class="line">                 * 注意MSG_PEEK参数，表示TCP Buffer不删除之前队列数据，从队列里接收数据</div><div class="line">                 */</div><div class="line"></div><div class="line">                n = recv(sock, &amp;c, <span class="number">1</span>, MSG_PEEK);</div><div class="line">                <span class="comment">/* DEBUG printf(&quot;%02X\n&quot;, c); */</span></div><div class="line">                <span class="keyword">if</span> ((n &gt; <span class="number">0</span>) &amp;&amp; (c == <span class="string">'\n'</span>))</div><div class="line">                    recv(sock, &amp;c, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    c = <span class="string">'\n'</span>;</div><div class="line">            }</div><div class="line">            buf[i] = c;</div><div class="line">            i++;</div><div class="line">        }</div><div class="line">        <span class="keyword">else</span></div><div class="line">            c = <span class="string">'\n'</span>;</div><div class="line">    }</div><div class="line">    buf[i] = <span class="string">'&#92;&#48;'</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span>(i);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这代码，没啥写头，很多功能都没实现，请求只实现了GET和POST，Header里只用了第一行，CGI里全局变量只定义了几个，并且我验证程序，发现CGI功能好像是有些问题的，但是因为我CGI水平比较水，懒得检测原因了，总体来说，程序比我之前的那个CGI Server要简单些，功能要稍微弱些吧。</p>
<p>下面放出我Github里的详细中文注释，欢迎指正，谢谢：</p>
<p><a href="https://github.com/armsword/Source/tree/master/tinyhttpd" title="tinyhttpd源码剖析" target="_blank" rel="external">https://github.com/armsword/Source/tree/master/tinyhttpd</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:armsword.com">
  </form>
</div>


  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/C-C/">C/C++</a><small>23</small></li>
  
    <li><a href="/categories/Database/">Database</a><small>2</small></li>
  
    <li><a href="/categories/Linux/">Linux</a><small>14</small></li>
  
    <li><a href="/categories/ML-NLP/">ML/NLP</a><small>3</small></li>
  
    <li><a href="/categories/Web-Script/">Web/Script</a><small>4</small></li>
  
    <li><a href="/categories/Windows/">Windows</a><small>2</small></li>
  
    <li><a href="/categories/我的生活/">我的生活</a><small>3</small></li>
  
    <li><a href="/categories/算法-数据结构/">算法/数据结构</a><small>5</small></li>
  
    <li><a href="/categories/计算机网络/">计算机网络</a><small>8</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2015/03/02/several-realization-of-hash-algorithm/">几种Hash算法的实现</a>
      </li>
    
      <li>
        <a href="/2015/01/31/baidu-lossless-music-downloader/">写了一个Chrome插件 - 百度无损音乐下载插件</a>
      </li>
    
      <li>
        <a href="/2015/01/26/jwsmtp-analyse/">jwSMTP源码剖析</a>
      </li>
    
      <li>
        <a href="/2014/12/01/learn-emacs-note/">Emacs学习笔记</a>
      </li>
    
      <li>
        <a href="/2014/11/22/move-from-wordpress-to-hexo/">将WordPress迁移到hexo并同时托管到Github和Gitcafe上</a>
      </li>
    
      <li>
        <a href="/2014/11/07/finding-job-result/">一蓑烟雨任平生</a>
      </li>
    
      <li>
        <a href="/2014/10/29/tinyhttpd-code-analyse/">tinyhttpd源码剖析</a>
      </li>
    
  </ul>
</div>



  

  <div class="widget tag">
<h3 class="title">友情链接</h3>
<ul class="entry">
<li><a href="http://linuxer.me" target="_blank" title="armsword的涅槃之地">armsword</a></li>
<li><a href="http://yanyiwu.com" target="_blank" title="YanYi">YanYi</a></li>
<li><a href="http://dreamshield.net/" target="_blank" title="DreamShield">DreamShield</a></li>
<li><a href="http://blog.purplecow.me" target="_blank" title="PurpleCow">PurpleCow</a></li>
<li><a href="http://cstdlib.com" target="_blank" title="徐小夫">徐小夫</a></li>
</ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft"> 
  
  &copy; 2015 armsword
  
  || 
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253622272'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253622272' type='text/javascript'%3E%3C/script%3E"));</script>

 
</div>
<div class="clearfix"></div>
</footer>
  <script src="/js/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id="totop" style="position:fixed;bottom:30px;right:30px;cursor: pointer;">
<a title="返回顶部"><img src="/imgs/scrollup.png"/></a>
</div>

<script src="/js/totop.js"></script>


</body>
</html>