<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 9 页 | armsword的涅槃之地</title>
  <meta name="author" content="armsword">
  
  <meta name="description" content="程序员,搜索引擎,网络编程,后台开发,北邮人,阿里巴巴,神马搜索,Linux,C,C++,Python">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="armsword的涅槃之地"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="icon" type="image/x-ico"> 
  <link rel="alternate" href="/atom.xml" title="armsword的涅槃之地" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">armsword的涅槃之地</a></h1>
  <h2><a href="/">莫思身外无穷事，且读生平未见书 || 不为无益之事，何以遣有涯之生</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/about-me">About</a></li>
    
      <li><a href="/document-information">文档资料</a></li>
    
  <li><a href="/atom.xml">RSS</a><li>
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2012-10-06T14:43:29.000Z"><a href="/2012/10/06/some-common-winsock-api-function/">10月 6 2012</a></time>
      
      
  
    <h1 class="title"><a href="/2012/10/06/some-common-winsock-api-function/">一些常用的Winsock API函数</a></h1>
  

    </header>
    <div class="entry">
      
        <p>socket即“套接字”，它是在网络编程中经常遇到的一个概念，确切的说它是网络编程的一种借口，通过socket无需了解复杂的网络协议细节便能轻松地完成网络通信的任务。</p>
<p>下面介绍一些常用的Winsock API函数。</p>
<p>1.完成初始化操作 ——WSAStartup()函数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> WSAStartup(</div><div class="line"> WORD wVersionRequired, <span class="comment">//使用宏MAKEWORD(X,Y)设置</span></div><div class="line"> LPWSADATA lpWSAData <span class="comment">//一个指向WSADATA结构的指针</span></div><div class="line"> );</div></pre></td></tr></table></figure>

<p>2.创建套接字 ——socket()函数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SOCKET socket(</div><div class="line"> <span class="typename">int</span> af,</div><div class="line"> <span class="typename">int</span> <span class="keyword">type</span>;</div><div class="line"> <span class="typename">int</span> protocol <span class="comment">//协议字段，默认为0</span></div><div class="line">);</div></pre></td></tr></table></figure>

<p>af表示协议的地址簇，通常使用AF_INET表示在网络层采用网际协议(IP)。</p>
<p>type是协议的套接字类型，通常TCP连接方式使用SOCK_STREAM(流连接方式)，UDP连接采用SOCK_DGRAM(数据报文方式)，而SOCK_RAW则被应用于原始套接字。</p>
<p>3.选定本机用来通信的接口对象——bind()函数</p>
<p>成功创建套接字后，下面就应该选定本机用来通信的接口对象，如IP地址和端口。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> bind(</div><div class="line"> SOCKET s, <span class="comment">//socket()返回的套接字</span></div><div class="line"> <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr FAR *addr, <span class="comment">//一个指向sockaddr结构的指针</span></div><div class="line"> <span class="keyword">int</span> namelen <span class="comment">//该结构体的长度</span></div><div class="line"> );</div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> sockaddr_in{</div><div class="line"> <span class="keyword">short</span> sin_family;<span class="comment">//地址协议簇，TCP/UDP时为AF_INET</span></div><div class="line"> u_short sin_port; <span class="comment">//指定的端口</span></div><div class="line"> <span class="keyword">struct</span> in_addr sin_addr; <span class="comment">//指定的IP地址</span></div><div class="line"> <span class="keyword">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">//</span></div><div class="line">};</div></pre></td></tr></table></figure>

<p>在使用sin_port和sin_addr时，要执行一次类型转换操作，这是因为网络和主机采用不同的方法。典型的使用方法如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lAddr.<span class="variable">sin_family =</span> AF_INET;</div><div class="line">lAddr.<span class="variable">sin_port =</span> htons(<span class="number">80</span>);</div><div class="line">lAddr.sin_addr.<span class="variable">s_addr =</span> inet_addr(<span class="string">"127.0.0.1"</span>);</div></pre></td></tr></table></figure>

<p>如果用户的主机只有一个IP地址，则可以使用如下代码绑定套接字到默认的IP地址：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">lAddr.sin_addr.s_addr </span>=<span class="string"> INADDR_ANY</span></div></pre></td></tr></table></figure>

<p>4.等待客户端的连接请求 ——listen()函数</p>
<p>对于TCP类型的服务端套接字，在完成bind操作后，下一步就应该调用listen()函数等待客户端的连接请求，其原型说明如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">int</span> <span class="keyword">listen</span>(</div><div class="line"> SOCKET <span class="keyword">s</span>;</div><div class="line"> <span class="keyword">int</span> backlog</div><div class="line"> );</div></pre></td></tr></table></figure>

<p>参数backlog是并发连接等待队列的长度。当某个客户端发送了连接请求时，如果此时服务端正在忙于处理其他连接，那么这个后来的连接就被放入等待队列中，等待服务器进行处理。如果此时等待队列已满，该连接请求将会被拒绝，返回出错代码WASECNOOREFUSED。</p>
<p>5.线程即将进入等待状态——accept()函数</p>
<p>当没有连接请求时，对于阻塞式套接字，如果程序调用了accept()函数，那么线程即将进入等待状态，直到有一个连接请求到达为止。accept()函数在接收到连接请求时，会为这个连接建立起一个新的套接字，该套接字负责和客户端通信，常被成为“会话套接字”。此前调用socket()函数也会返回一个套接字，它负责监听和接收连接请求，因此被成为“监听套接字”。accept()函数的原型说明如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SOCKET accept(</div><div class="line"> SOCKET s,</div><div class="line"> struct sockaddr_in <span class="preprocessor">FAR</span>* addr,</div><div class="line"> <span class="keyword">int</span> <span class="preprocessor">FAR</span>* addrlen</div><div class="line"> )<span class="comment">;</span></div></pre></td></tr></table></figure>

<p>如果accept()函数执行成功，将会返回一个新的用于通信的会话套接字；否则将会返回出错码 INVALID_SOCKET，可以通过调用WSAGetLastError()函数来得到详细的出错信息。</p>
<p>6.向服务器发出连接请求——connect()函数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> connect(</div><div class="line"> SOCKET s,</div><div class="line"> <span class="keyword">const</span> <span class="keyword">struct</span> sockaddr FAR *name,</div><div class="line"> <span class="keyword">int</span> namelen</div><div class="line"> );</div></pre></td></tr></table></figure>

<p>7.收发信息——send()/recv()函数</p>
<p>如果服务端与客户端成功建立了连接，便可以调用函数send()和recv()收发信息。这2个函数的原型说明如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> send(</div><div class="line"> SOCKET s,<span class="comment">//调用accept()函数接收客户端的连接请求后返回的套接字</span></div><div class="line"> <span class="keyword">const</span> <span class="keyword">char</span> FAR *buf,</div><div class="line"> <span class="keyword">int</span> len,</div><div class="line"> <span class="keyword">int</span> flags</div><div class="line"> );</div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> recv(</div><div class="line"> SOCKET s,</div><div class="line"> <span class="keyword">char</span> FAR *buf,</div><div class="line"> <span class="keyword">int</span> len,</div><div class="line"> <span class="keyword">int</span> flags</div><div class="line"> );</div></pre></td></tr></table></figure>

<p>如果函数调用成功，则返回实际发送或接收的字节数。</p>
<p>对于send()函数而言，如果想成功发送指定数量的数据，调用方法如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="keyword">while</span> (<span class="keyword">length</span> &<span class="keyword">gt</span>; <span class="number">0</span>)</div><div class="line">{</div><div class="line"> ret = <span class="keyword">send</span>(sock,&amp;(buffer[i]),<span class="keyword">length</span>,<span class="number">0</span>)</div><div class="line"> <span class="keyword">if</span>(ret = <span class="number">0</span>)</div><div class="line"> <span class="keyword">break</span>;</div><div class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(ret == SOCKET_ERROR)</div><div class="line"> <span class="keyword">break</span>;</div><div class="line"> i = i + ret;</div><div class="line"> <span class="keyword">length</span> = <span class="keyword">length</span> - ret;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果函数调用失败，将返回SOCKET_ERROR,最常见的错误代码是WSAECONNABORTED,表示对方关闭了连接或此操作已经超时。</p>
<p>send()与recv()函数通常都是用在TCP类型的套接字上，而在UDP类型的套接字中也有专门的发送/接收函数：sendto()/recvfrom()。</p>
<p>8.关闭指定的套接字——closesocket()</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> closesocket(SOCKET s);</div></pre></td></tr></table></figure>

<p>图一张，详细表示了TCP套接字的调用过程：</p>
<p><img src="http://armsword.com/wp-content/uploads/2012/10/20121006212505.jpg" alt=""></p>
<p>下面给出一个典型的TCP套接字程序代码：</p>
<p>服务器端：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;winsock.h&gt;</span></div><div class="line"><span class="comment">//使用前需要包含库ws2_32.lib</span></div><div class="line"><span class="preprocessor">#<span class="keyword">pragma</span> comment(lib,&quot;ws2_32&quot;)</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> MYPORT 1111 //监听端口</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> BACKLOG 10 //最大连接数</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">{</div><div class="line"> SOCKET sockfd,new_fd; <span class="comment">//套接字，监听套接字，会话套接字</span></div><div class="line"> <span class="keyword">struct</span> sockaddr_in my_addr; <span class="comment">//本地地址信息</span></div><div class="line"> <span class="keyword">struct</span> sockaddr_in their_addr; <span class="comment">//客户地址信息</span></div><div class="line"> WSADATA ws;</div><div class="line"> <span class="keyword">int</span> sin_size;</div><div class="line"> <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line"> <span class="keyword">char</span> Buffer[MAX_PATH];</div><div class="line"></div><div class="line">WSAStartup(MAKEWORD(<span class="number">2</span>,<span class="number">2</span>),&amp;ws);</div><div class="line"> <span class="keyword">if</span> ((sockfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>)) == INVALID_SOCKET)</div><div class="line"> {</div><div class="line"> exit(<span class="number">0</span>);</div><div class="line"> }</div><div class="line">my_addr.sin_family = AF_INET;</div><div class="line">my_addr.sin_port = htons(MYPORT);</div><div class="line">my_addr.sin_addr.S_un.S_addr = INADDR_ANY;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (bind(sockfd,(<span class="keyword">struct</span> sockaddr*)&amp;my_addr,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr)) == -<span class="number">1</span>)</div><div class="line">{</div><div class="line"> closesocket(sockfd);</div><div class="line"> exit(<span class="number">0</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">if</span> (listen(sockfd,BACKLOG) == SOCKET_ERROR)</div><div class="line">{</div><div class="line"> closesocket(sockfd);</div><div class="line"> exit(<span class="number">0</span>);</div><div class="line">}</div><div class="line"></div><div class="line">sin_size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</div><div class="line"></div><div class="line"><span class="keyword">if</span> ((new_fd = accept(sockfd,(<span class="keyword">struct</span> sockaddr*)&amp;their_addr,&amp;sin_size)) == INVALID_SOCKET)</div><div class="line">{</div><div class="line"> closesocket(sockfd);</div><div class="line"> exit(<span class="number">0</span>);</div><div class="line">}</div><div class="line">printf(&quot;\nRequest Has Been Accept!\n\n&quot;);</div><div class="line">printf(&quot;\tClient IP:%s\n&quot;,inet_ntoa(their_addr.sin_addr));<span class="comment">//将网络地址转换成“.”点隔的字符串格式</span></div><div class="line">printf(&quot;\tClient Port: %d\n&quot;,ntohs(their_addr.sin_port));<span class="comment">//将一个无符号短整形数从网络字节顺序转换为主机字节顺序</span></div><div class="line">num = recv(new_fd,Buffer,MAX_PATH,<span class="number">0</span>);</div><div class="line">Buffer[num - <span class="number">1</span>] = <span class="string">'&#92;&#48;'</span>;</div><div class="line">printf(&quot;\nMsg:%s\n&quot;,Buffer);</div><div class="line">closesocket(sockfd);</div><div class="line">closesocket(new_fd);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">}</div></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;winsock.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">pragma</span> comment(lib,&quot;ws2_32&quot;)</span></div><div class="line"><span class="preprocessor">#<span class="keyword">define</span> PORT 1111</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</div><div class="line">{</div><div class="line"> SOCKET sockfd;</div><div class="line"> WSADATA ws;</div><div class="line"> <span class="keyword">struct</span> sockaddr_in their_addr;</div><div class="line"> <span class="keyword">char</span> Buffer[MAX_PATH];</div><div class="line"> <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line"> <span class="keyword">if</span> (argc != <span class="number">2</span>)</div><div class="line"> {</div><div class="line"> <span class="built_in">printf</span>(&quot;Usage:client1.exe&lt;IP Address&gt;\n&quot;);</div><div class="line"> <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line"> }</div><div class="line"> WSAStartup(MAKEWORD(<span class="number">2</span>,<span class="number">2</span>),&amp;ws);</div><div class="line"> <span class="keyword">if</span> ((sockfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>)) == INVALID_SOCKET)</div><div class="line"> {</div><div class="line"> <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line"> }</div><div class="line"> their_addr.sin_family = AF_INET;</div><div class="line"> their_addr.sin_port = htons(PORT);</div><div class="line"> their_addr.sin_addr.S_un.S_addr = inet_addr(argv[<span class="number">1</span>]);</div><div class="line"> <span class="keyword">if</span> (connect(sockfd,(<span class="keyword">struct</span> sockaddr*)&amp;their_addr,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr)) ==SOCKET_ERROR)</div><div class="line"> {</div><div class="line"> closesocket(sockfd);</div><div class="line"> <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line"> }</div><div class="line"> gets(Buffer);</div><div class="line"> num = send(sockfd,Buffer,MAX_PATH,<span class="number">0</span>);</div><div class="line"> closesocket(sockfd);</div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如图所示：</p>
<p><img src="http://armsword.com/wp-content/uploads/2012/10/20121006212506.jpg" alt=""></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2012-10-03T11:47:11.000Z"><a href="/2012/10/03/file-manipulation/">10月 3 2012</a></time>
      
      
  
    <h1 class="title"><a href="/2012/10/03/file-manipulation/">Windows下文件操作的一些常用函数</a></h1>
  

    </header>
    <div class="entry">
      
        <p>其实这些API基本上会经常用到，不过俗语说：“好记忆，不如烂笔头。”我还是记录下一些常用的文件操作函数吧，正好也能帮自己理理思路。文章中的内容，在MSDN上都可以找到的，也有不少著作多多少少也有介绍。</p>
<p>1.打开文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FILE *fopen(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode);</div></pre></td></tr></table></figure>

<p>如果文件打开成功，则该函数返回一个指向打开文件的FILE类型指针；否则将返回一个NULL表示出错。</p>
<p>在Windows提供的API中，CreateFile()函数也可以打开或创建文件。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">HANDLE</span> CreateFile(</div><div class="line"> LPCSTR lpFileName, <span class="comment">//文件名，最大长度为MAX_PATH</span></div><div class="line"> DWORD dwDesiredAccess, <span class="comment">//存取方式，文件查询权限，读写权限</span></div><div class="line"> DWORD dwShareMode, <span class="comment">//共享属性</span></div><div class="line"> LPSECURITY_ATTRIBUTES lpSecurityAttributes,<span class="comment">//安全属性</span></div><div class="line"> DWORD dwCreationDisposition,<span class="comment">//文件是否存在来决定对其进行的操作</span></div><div class="line"> DWORD dwFlagsAndAttributes, <span class="comment">//文件属性和参数</span></div><div class="line"> <span class="keyword">HANDLE</span> hTemplateFile <span class="comment">//文件模版</span></div><div class="line"> );</div></pre></td></tr></table></figure>

<p>如果文件打开成功，则返回文件句柄；否则返回INVALID_HANDLE_VALUE,可通过GetLastError函数来返回错误信息。</p>
<p>2.关闭文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> fclose(<span class="keyword">FILE</span> *stream);</div></pre></td></tr></table></figure>

<p>stream为一个指向已经打开文件的指针。如果函数执行成功，将返回值0；否则返回EOF(-1)。</p>
<p>使用API关闭文件比较简单，使用CloseHandle()函数就可以。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">BOOL</span> CloseHandle( HANDLE hObject );</div></pre></td></tr></table></figure>

<p>hObject为使用CreateFile()函数打开文件后返回的句柄。若函数执行成功，则返回一个非0值；否则将返回0。另外，该函数不仅仅可以关闭文件，也可以用其他句柄的操作。</p>
<p>3.读文件</p>
<p>fgetc()函数:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> fgetc(<span class="keyword">FILE</span> *stream);<span class="comment">//stream为FILE类型的指针</span></div></pre></td></tr></table></figure>

<p>该函数从文件中读取出一个字符，并将文件指针向前移动一位。若读取成功，则返回该字符；若出错或指针到达文件末尾，则返回EOF。</p>
<p>fread():</p>
<p>fread()可以精确地控制每次读取多个字节的内容。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">size_t fread(</div><div class="line"> <span class="keyword">void</span> *buffer, <span class="comment">//指向数据存放缓冲区的指针</span></div><div class="line"> size_t <span class="keyword">size</span>, <span class="comment">//单个字符占用字节数</span></div><div class="line"> size_t <span class="keyword">count</span>, <span class="comment">//要进行读写多少个size的字符</span></div><div class="line"> <span class="keyword">FILE</span> *stream <span class="comment">//指向某个已打开文件的FILE类型指针</span></div><div class="line"> );</div></pre></td></tr></table></figure>

<p>如果文件已二进制形式打开，使用fread()可以读取任何类型的数据。如果函数执行成功，则返回实际读取的字符数。</p>
<p>fscanf(): 变长参数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int fscanf(FILE *, const char *, <span class="keyword">...</span>);//读的是磁盘上的文件</div></pre></td></tr></table></figure>

<p>win32提供的读文件API为ReadFile():</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">BOOL</span> ReadFile(</div><div class="line"> HANDLE hFile, <span class="comment">//CreateFile()返回的文件句柄</span></div><div class="line"> LPVOID lpBuffer,<span class="comment">//保存需要读入数据的缓冲区指针</span></div><div class="line"> DWORD nNumberOfBytesToRead,<span class="comment">//指定需要读入的字节数</span></div><div class="line"> LPDWORD lpNumberOfBytesRead, <span class="comment">//返回实际读入的字节数</span></div><div class="line"> LPOVERLAPPED lpOverlapped <span class="comment">//异步读取使用，同步时为NULL</span></div><div class="line"> );</div></pre></td></tr></table></figure>

<p>如果函数执行成功，将会返回一个非0值。如果返回FALSE且读入字节数为0，表示文件已经到达末尾。</p>
<p>4.写文件</p>
<p>fputs()函数:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> <span class="built_in">fputs</span>(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>, FILE *stream);</div></pre></td></tr></table></figure>

<p>string是将要写入到文件中的字符，stream是指向某个文件的FILE类型指针。若函数执行成功，将返回被成功写入到文件中的字符，若执行失败，则返回EOF。</p>
<p>fwrite()函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">size_t fwrite( const <span class="keyword">void</span> *buffer, size_t <span class="keyword">size</span>, size_t <span class="keyword">count</span>, <span class="keyword">FILE</span> *stream );</div></pre></td></tr></table></figure>

<p>fprintf()函数：同fscanf()相似，也是变长参数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int fprintf(FILE *, const char *, <span class="keyword">...</span>);</div></pre></td></tr></table></figure>

<p>WriteFile()函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BOOL WriteFile(</div><div class="line"> HANDLE hFile,</div><div class="line"> LPCVOID lpBuffer,</div><div class="line"> <span class="preprocessor">DWORD</span> nNumberOfBytesToWrite,</div><div class="line"> LPDWORD lpNumberOfBytesWritten,</div><div class="line"> LPOVERLAPPED lpOverlapped</div><div class="line"> )<span class="comment">;</span></div></pre></td></tr></table></figure>

<p>5.文件定位</p>
<p>rewind()函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> rewind(<span class="keyword">FILE</span> *stream);</div></pre></td></tr></table></figure>

<p>该函数可以使文件指针返回到文件开头，没返回值。</p>
<p>fseek()函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> fseek(</div><div class="line"> <span class="keyword">FILE</span> *stream,</div><div class="line"> <span class="keyword">long</span> offset, <span class="comment">//偏移量，相当于origin而言</span></div><div class="line"> <span class="keyword">int</span> origin <span class="comment">//偏移起始地址</span></div><div class="line"> );</div></pre></td></tr></table></figure>

<p>fseek()函数一般用于二进制文件，因为文本文件要发生字符转换，在计算位置时会发生混乱。如果想知道指针移动到什么位置，可以使用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> ftell(<span class="keyword">FILE</span> *stream);</div></pre></td></tr></table></figure>

<p>该函数的功能是返回当前文件指针的位置，相对于文件开头的偏移量。如果出错，返回-1。</p>
<p>与fseek()相对应的Windows API是SetFilePointer()函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">DWORD SetFilePointer(</div><div class="line"> HANDLE hFile,</div><div class="line"> <span class="keyword">LONG</span> lDistanceToMove, <span class="comment">//移动的字节数低32位</span></div><div class="line"> PLONG lpDistanceToMoveHigh,<span class="comment">//移动的字节数高32位，主要在64位系统里</span></div><div class="line"> DWORD dwMoveMethod <span class="comment">//移动起始位置</span></div><div class="line"> )</div></pre></td></tr></table></figure>

<p>6.文件目录</p>
<p>CreateDirectory()函数：</p>
<p>用于目录的创建。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">BOOL</span> CreateDirectory(</div><div class="line"> LPCSTR lpPathName, <span class="comment">//创建目录的名称</span></div><div class="line"> LPSECURITY_ATTRIBUTES lpSecurityAttributes <span class="comment">//安全属性描述，通常为NULL</span></div><div class="line"> );</div></pre></td></tr></table></figure>

<p>RemoveDirectory()函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">BOOL</span> RemoveDirectory( LPCSTR lpPathName )</div></pre></td></tr></table></figure>

<p>需要注意的是，该目录必须为一个空目录，即该目录下不能有任何文件或文件夹。</p>
<p>7.文件操作</p>
<p>删除文件 DeleteFile()：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BOOL <span class="keyword">DeleteFile</span>( LPCSTR lpFileName );</div></pre></td></tr></table></figure>

<p>文件的复制 CopyFile()：</p>
<p>BOOL CopyFile(<br>LPCSTR lpExistingFileName, //源文件名<br>LPCSTR lpNewFileName, //目标文件名<br>BOOL bFailIfExists //目标是否存在，FALSE强制覆盖<br>)</p>
<p>文件的移动 MoveFile()：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">BOOL</span> MoveFile(</div><div class="line"> LPCSTR lpExistingFileName, <span class="comment">//源文件路径</span></div><div class="line"> LPCSTR lpNewFileName <span class="comment">//目标文件路径</span></div><div class="line"> );</div></pre></td></tr></table></figure>

<p>8.文件属性</p>
<p>可以使用2个函数对文件的属性进行控制，他们是GetFileAttributes()函数和SetFileAttributes()函数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">DWORD</span> GetFileAttributes( LPCSTR lpFileName )<span class="comment">;</span></div></pre></td></tr></table></figure>

<p>使用GetFileAttributes()得到函数的文件属性，若执行成功，则返回文件的属性，否则返回OxFFFFFFFF。</p>
<p>使用SetFileAttributes()函数设置文件属性：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BOOL <span class="keyword">SetFileAttributes</span>( LPCSTR lpFileName, DWORD dwFileAttributes )<span class="comment">;</span></div></pre></td></tr></table></figure>


      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2012-10-02T12:24:07.000Z"><a href="/2012/10/02/based-on-csocket-class-gadgets/">10月 2 2012</a></time>
      
      
  
    <h1 class="title"><a href="/2012/10/02/based-on-csocket-class-gadgets/">基于CSocket类的文件传输小软件</a></h1>
  

    </header>
    <div class="entry">
      
        <p>看了点网络套接字编程，正好硬盘里面有个文件传输的软件，自己看了看源代码，也模仿着写了一个小玩意。功能比较简单，就是简单的局域网文件传输。这里把看到的那个小程序的源代码拿出来分析分析，高手就飘过吧，比较基础的小东西。</p>
<p>MFC对套接字函数进行了封装，提供了CAsyncSocket类和CSocket类用于网络程序的开发。CAsyncSocket类对套接字函数进行了简单封装，注意MFC封装后的Csocket的头文件，需要在Stdafx.h包含#include &lt;afxsock.h&gt;。</p>
<p>CAsyncSocket类的主要方法、事件如下:</p>
<p>1.Create 方法 ：用于创建一个Windows套接字。</p>
<p>2.GetPeerName 方法： 用于获取套接字连接的IP地址信息。</p>
<p>3.Accept 方法： 用于接受客户端的连接。</p>
<p>4.Bind 方法： 用于将IP地址和端口号绑定到套接字上。</p>
<p>5.Connect 方法： 用于发送一个连接请求。</p>
<p>6.Close 方法： 用于关闭套接字。</p>
<p>7.Listen 方法 ：用于将套接字置于监听模式。</p>
<p>8.Receive 方法： 用于在流式套接字中接收数据，如TCP。</p>
<p>9.ReceiveFrom 方法：用于从数据包套接字中接收数据，如UDP。</p>
<p>10.end 方法：用于向流式套接字中发送数据。</p>
<p>11.SendTo 方法：用于在流式套接字或数据包套接字上发送数据。</p>
<p>12.ShutDown 方法：用于在套接字上断开数据的发送或接收。</p>
<p>在传输文件时候，我们需要定义一个文件结构，当然是用结构体的形式定义了，形式如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SOCKET_STREAM_FILE_INFO</span> </span>{</div><div class="line"></div><div class="line">TCHAR szFileTitle[<span class="number">128</span>]; <span class="comment">//文件的标题名</span></div><div class="line"> DWORD dwFileAttributes; <span class="comment">//文件的属性</span></div><div class="line"> FILETIME ftCreationTime; <span class="comment">//文件的创建时间</span></div><div class="line"> FILETIME ftLastAccessTime; <span class="comment">//文件的最后访问时间</span></div><div class="line"> FILETIME ftLastWriteTime; <span class="comment">//文件的最后修改时间</span></div><div class="line"> DWORD nFileSizeHigh; <span class="comment">//文件大小的高位双字</span></div><div class="line"> DWORD nFileSizeLow; <span class="comment">//文件大小的低位双字</span></div><div class="line"> DWORD dwReserved0; <span class="comment">//保留，为0</span></div><div class="line"> DWORD dwReserved1; <span class="comment">//保留，为0</span></div><div class="line"></div><div class="line">} SOCKET_STREAM_FILE_INFO, * PSOCKET_STREAM_FILE_INFO;</div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">  typedef struct _WIN32_FIND_DATA {</div><div class="line">  <span class="preprocessor">DWORD</span>    dwFileAttributes<span class="comment">;</span></div><div class="line">  FILETIME ftCreationTime<span class="comment">;</span></div><div class="line">  FILETIME ftLastAccessTime<span class="comment">;</span></div><div class="line">  FILETIME ftLastWriteTime<span class="comment">;</span></div><div class="line">  <span class="preprocessor">DWORD</span>    nFileSizeHigh<span class="comment">;</span></div><div class="line">  <span class="preprocessor">DWORD</span>    nFileSizeLow<span class="comment">;</span></div><div class="line">  <span class="preprocessor">DWORD</span>    dwReserved0<span class="comment">;</span></div><div class="line">  <span class="preprocessor">DWORD</span>    dwReserved1<span class="comment">;</span></div><div class="line">  TCHAR    cFileName[ MAX_PATH ]<span class="comment">;</span></div><div class="line">  TCHAR    cAlternateFileName[ <span class="number">14</span> ]<span class="comment">;</span></div><div class="line">} WIN32_FIND_DATA, *PWIN32_FIND_DATA<span class="comment">;</span></div></pre></td></tr></table></figure>

<p>现在我们分析下服务端Server：</p>
<h3 id="FindClose">FindClose</h3>
<p>The <strong>FindClose</strong> function closes the specified search handle. The <a><strong>FindFirstFile</strong></a> and <a><strong>FindNextFile</strong></a> functions use the search handle to locate files with names that match a given name.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BOOL <span class="keyword">FindClose</span>( HANDLE hFindFile)<span class="comment">;</span></div></pre></td></tr></table></figure>

<h3 id="FindFirstFile">FindFirstFile</h3>
<p>The <strong>FindFirstFile</strong> function searches a directory for a file whose name matches the specified file name. <strong>FindFirstFile</strong> examines subdirectory names as well as file names.</p>
<p>To specify additional attributes to be used in the search, use the <a><strong>FindFirstFileEx</strong></a> function.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">HANDLE</span> FindFirstFile( LPCTSTR lpFileName, LPWIN32_FIND_DATA lpFindFileData);</div></pre></td></tr></table></figure>

<p>服务端主要代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> CServerDlg::OnButtonLicsen()</div><div class="line">{</div><div class="line"> <span class="comment">// TODO: Add your control notification handler code here</span></div><div class="line"> CFileDialog Dlg(TRUE);</div><div class="line"> <span class="keyword">if</span>(Dlg.DoModal()!=IDOK)</div><div class="line"> <span class="keyword">return</span>;</div><div class="line"></div><div class="line"> CFile myFile;</div><div class="line"> <span class="keyword">if</span>(!myFile.Open(Dlg.GetPathName(), CFile::modeRead | CFile::typeBinary))</div><div class="line"> {</div><div class="line"> AfxMessageBox(&amp;quot;文件不存在!&amp;quot;,MB_OK|MB_ICONERROR);</div><div class="line"> <span class="keyword">return</span>;</div><div class="line"> }</div><div class="line"></div><div class="line"> CSocket sockSrvr;</div><div class="line"> sockSrvr.Create(<span class="number">800</span>);</div><div class="line"></div><div class="line">sockSrvr.Listen();</div><div class="line"> CSocket sockRecv;</div><div class="line"> sockSrvr.Accept(sockRecv);</div><div class="line"></div><div class="line">SOCKET_STREAM_FILE_INFO StreamFileInfo;</div><div class="line"> WIN32_FIND_DATA FindFileData;</div><div class="line"></div><div class="line">FindClose(FindFirstFile(Dlg.GetPathName(),&amp;amp;FindFileData));</div><div class="line"> <span class="built_in">memset</span>(&amp;amp;StreamFileInfo,<span class="number">0</span>,<span class="keyword">sizeof</span>(SOCKET_STREAM_FILE_INFO));</div><div class="line"> <span class="built_in">strcpy</span>(StreamFileInfo.szFileTitle,myFile.GetFileTitle());</div><div class="line"></div><div class="line">StreamFileInfo.dwFileAttributes = FindFileData.dwFileAttributes;</div><div class="line"> StreamFileInfo.ftCreationTime = FindFileData.ftCreationTime;</div><div class="line"> StreamFileInfo.ftLastAccessTime = FindFileData.ftLastAccessTime;</div><div class="line"> StreamFileInfo.ftLastWriteTime = FindFileData.ftLastWriteTime;</div><div class="line"> StreamFileInfo.nFileSizeHigh = FindFileData.nFileSizeHigh;</div><div class="line"> StreamFileInfo.nFileSizeLow = FindFileData.nFileSizeLow;</div><div class="line"></div><div class="line">sockRecv.Send(&amp;amp;StreamFileInfo,<span class="keyword">sizeof</span>(SOCKET_STREAM_FILE_INFO));</div><div class="line"></div><div class="line">UINT dwRead=<span class="number">0</span>;</div><div class="line"> <span class="keyword">while</span>(dwRead&amp;lt;StreamFileInfo.nFileSizeLow)</div><div class="line"> {</div><div class="line"> byte* data = <span class="keyword">new</span> byte[<span class="number">1024</span>];</div><div class="line"> UINT dw=myFile.Read(data, <span class="number">1024</span>);</div><div class="line"> sockRecv.Send(data, dw);</div><div class="line"> dwRead+=dw;</div><div class="line"> }</div><div class="line"> myFile.Close();</div><div class="line"></div><div class="line">sockRecv.Close();</div><div class="line"> AfxMessageBox(&amp;quot;发送完毕！&amp;quot;);</div><div class="line">}</div></pre></td></tr></table></figure>

<p><img src="http://armsword.com/wp-content/uploads/2012/10/20121002192522.jpg" alt=""></p>
<p>客户端Client就比较简单了，就不做分析了，不过我们需要判断是否输入了IP，这样我们需要对编辑框里面的内容进行判断，主要是为了禁止/允许</p>
<p>指定窗口的允许/禁止指定的窗口或控件接受鼠标和键盘的输入。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void CClientDlg<span class="value">::<span class="function">OnChangeEditIpaddress</span>()</span></div><div class="line">{</div><div class="line"></div><div class="line"> CString szIpAddress;</div><div class="line"></div><div class="line"> <span class="function">GetDlgItemText</span>(IDC_EDIT_IPADDRESS,szIpAddress);</div><div class="line"> <span class="function">if</span>(szIpAddress<span class="class">.IsEmpty</span>())</div><div class="line"> <span class="function">GetDlgItem</span>(IDC_BUTTON_SEND)-&amp;gt;<span class="function">EnableWindow</span>(FALSE);</div><div class="line"> else</div><div class="line"> <span class="function">GetDlgItem</span>(IDC_BUTTON_SEND)-&amp;gt;<span class="function">EnableWindow</span>(TRUE);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>客户端的主要代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="literal">void</span> CClientDlg<span class="tag">::OnButtonSend</span>()</div><div class="line">{</div><div class="line"> <span class="comment">// TODO: Add your control notification handler code here</span></div><div class="line"> AfxSocketInit(<span class="built_in">NULL</span>);</div><div class="line"> CSocket sockClient;</div><div class="line"> sockClient<span class="built_in">.</span>Create();</div><div class="line"></div><div class="line">CString szIP;</div><div class="line"> GetDlgItemText(IDC_EDIT_IPADDRESS,szIP);</div><div class="line"></div><div class="line"> <span class="keyword">if</span>(<span class="subst">!</span>sockClient<span class="built_in">.</span>Connect((LPCTSTR)szIP, <span class="number">800</span>))</div><div class="line"> {</div><div class="line"> AfxMessageBox(<span class="subst">&</span>amp;quot;连接到对方机器失败<span class="subst">!&</span>amp;quot;);</div><div class="line"> <span class="keyword">return</span>;</div><div class="line"> }</div><div class="line"> SOCKET_STREAM_FILE_INFO StreamFileInfo;</div><div class="line"> sockClient<span class="built_in">.</span>Receive(<span class="subst">&</span>amp;amp;StreamFileInfo,sizeof(SOCKET_STREAM_FILE_INFO));</div><div class="line"></div><div class="line">CFile destFile(StreamFileInfo<span class="built_in">.</span>szFileTitle, CFile<span class="tag">::modeCreate</span> <span class="subst">|</span> CFile<span class="tag">::modeWrite</span> <span class="subst">|</span> CFile<span class="tag">::typeBinary</span>);</div><div class="line"></div><div class="line">UINT dwRead <span class="subst">=</span> <span class="number">0</span>;</div><div class="line"> <span class="keyword">while</span>(dwRead<span class="subst">&</span>amp;<span class="literal">lt</span>;StreamFileInfo<span class="built_in">.</span>nFileSizeLow)</div><div class="line"> {</div><div class="line"> byte<span class="subst">*</span> <span class="built_in">data</span> <span class="subst">=</span> <span class="literal">new</span> byte<span class="preprocessor">[</span><span class="number">1024</span><span class="preprocessor">]</span><span class="markup">;</span></div><div class="line"> memset(data,0,1024);</div><div class="line"></div><div class="line">UINT dw=sockClient.Receive(data, 1024);</div><div class="line"> destFile.Write(data, dw);</div><div class="line"></div><div class="line">dwRead+=dw;</div><div class="line"> }</div><div class="line"></div><div class="line">SetFileTime((HANDLE)destFile.m_hFile,&amp;amp;StreamFileInfo.ftCreationTime,</div><div class="line"> &amp;amp;StreamFileInfo.ftLastAccessTime,&amp;amp;StreamFileInfo.ftLastWriteTime);</div><div class="line"> destFile.Close();</div><div class="line"> SetFileAttributes(StreamFileInfo.szFileTitle,StreamFileInfo.dwFileAttributes);</div><div class="line"> sockClient.Close();</div><div class="line"> AfxMessageBox(&amp;quot;接收完毕！&amp;quot;);</div><div class="line">}</div></pre></td></tr></table></figure>

<p><img src="http://armsword.com/wp-content/uploads/2012/10/20121002192521.jpg" alt=""></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2012-09-24T07:47:20.000Z"><a href="/2012/09/24/determine-the-computers-byte-order/">9月 24 2012</a></time>
      
      
  
    <h1 class="title"><a href="/2012/09/24/determine-the-computers-byte-order/">C语言判断电脑的字节顺序</a></h1>
  

    </header>
    <div class="entry">
      
        <p>判断机器的字节顺序是高字节在前还是低字节在前的几个C语言小技巧：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">{</div><div class="line"> <span class="keyword">int</span> x = <span class="number">1</span>;</div><div class="line"> <span class="keyword">if</span>(*(<span class="keyword">char</span>*)&amp;x == <span class="number">1</span>)</div><div class="line"> <span class="built_in">printf</span>(&quot;little-endian\n&quot;);</div><div class="line"> <span class="keyword">else</span></div><div class="line"> <span class="built_in">printf</span>(&quot;big-endian\n&quot;);</div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>原理与以下代码相似：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">{</div><div class="line"> <span class="keyword">int</span> x;</div><div class="line"> <span class="keyword">char</span> m,n;</div><div class="line"> x=<span class="number">0x1122</span>;</div><div class="line"> m=((<span class="keyword">char</span>*)&amp;x)[<span class="number">0</span>]; <span class="comment">//低地址单元</span></div><div class="line"> n=((<span class="keyword">char</span>*)&amp;x)[<span class="number">1</span>]; <span class="comment">//高地址单元</span></div><div class="line"> printf(&quot;%x\n%x\n&quot;,m,n);</div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在一些书籍上还看到一种方法甚是巧妙，使用的是联合的方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">union</span>{</div><div class="line"> <span class="keyword">int</span> i;</div><div class="line"> <span class="keyword">char</span> c[<span class="keyword">sizeof</span>(<span class="keyword">int</span>)];</div><div class="line">} x;</div><div class="line"></div><div class="line">x.i = <span class="number">1</span>;</div><div class="line"><span class="keyword">if</span>(x.c[<span class="number">0</span>] == <span class="number">1</span>)</div><div class="line"> <span class="built_in">printf</span>(&quot;little endian\n&quot;);</div><div class="line"><span class="keyword">else</span></div><div class="line"> <span class="built_in">printf</span>(&quot;big endian\n&quot;);</div></pre></td></tr></table></figure>


      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2012-09-13T10:16:56.000Z"><a href="/2012/09/13/language-interview-questions/">9月 13 2012</a></time>
      
      
  
    <h1 class="title"><a href="/2012/09/13/language-interview-questions/">12个有趣的C语言面试题</a></h1>
  

    </header>
    <div class="entry">
      
        <p>本文我在CSDN见到的（可能CSDN复制别人的），感觉挺有意思，许多在win7环境下不能运行的程序，我基本都有所修改，并且许多添加了自己的理解。看看吧，许多其实问题都是明文禁止使用的，但是像我这种新手难免也会犯如此错误，还是请大牛们多多指教。</p>
<p><strong>1.gets()函数</strong></p>
<p>问：请找出下面代码里的问题：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line"> <span class="keyword">char</span> buff[<span class="number">10</span>];</div><div class="line"> <span class="built_in">memset</span>(buff,<span class="number">0</span>,<span class="keyword">sizeof</span>(buff));</div><div class="line"></div><div class="line"> gets(buff);</div><div class="line"></div><div class="line"> <span class="built_in">printf</span>(&quot;\n The buffer entered is [%s]\n&quot;,buff);</div><div class="line"></div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>答：上面代码里的问题在于函数gets()的使用，这个函数从stdin接收一个字符串而不检查它所复制的缓存的容积，这可能会导致缓存溢出。这里推荐使用标准函数fgets()代替。解决代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#include&lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#include&lt;string.h&gt;</span></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line"> <span class="keyword">char</span> buff[<span class="number">10</span>];</div><div class="line"> memset(buff,<span class="number">0</span>,sizeof(buff));</div><div class="line"></div><div class="line"> fgets(buff,<span class="number">10</span>,<span class="keyword">stdin</span>);</div><div class="line"></div><div class="line"> printf(&quot;\n The buffer entered is [%s]\n&quot;,buff);</div><div class="line"></div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>2.strcpy()函数</strong></p>
<p>问：下面是一个简单的密码保护功能，你能在不知道密码的情况下将其破解吗？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</div><div class="line">{</div><div class="line"> <span class="keyword">int</span> flag = <span class="number">0</span>;</div><div class="line"> <span class="keyword">char</span> passwd[<span class="number">10</span>];</div><div class="line"></div><div class="line"> <span class="built_in">memset</span>(passwd,<span class="number">0</span>,<span class="keyword">sizeof</span>(passwd));</div><div class="line"></div><div class="line"> <span class="built_in">strcpy</span>(passwd, argv[<span class="number">1</span>]);</div><div class="line"></div><div class="line"> <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">strcmp</span>(&quot;LinuxGeek&quot;, passwd))</div><div class="line"> {</div><div class="line"> flag = <span class="number">1</span>;</div><div class="line"> }</div><div class="line"></div><div class="line"> <span class="keyword">if</span>(flag)</div><div class="line"> {</div><div class="line"> <span class="built_in">printf</span>(&quot;\n Password cracked \n&quot;);</div><div class="line"> }</div><div class="line"> <span class="keyword">else</span></div><div class="line"> {</div><div class="line"> <span class="built_in">printf</span>(&quot;\n Incorrect passwd \n&quot;);</div><div class="line"></div><div class="line"> }</div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>答：破解上述加密的关键在于利用攻破strcpy()函数的漏洞。所以用户在向“passwd”缓存输入随机密码的时候并没有提前检查“passwd”的容量是否足够。所以，如果用户输入一个足够造成缓存溢出并且重写“flag”变量默认值所存在位置的内存的长“密码”，即使这个密码无法通过验证，flag验证位也变成了非零，也就可以获得被保护的数据了。例如：</p>
<p>win7下vs2010结果：<br>passwd地址为0x0026fe60。<br>flage地址为0x0026fe74.<br>输入10个字符以上都有windows的断言错误。<br>输入21个字符会输出Password cracked</p>
<p>虽然上面的密码并不正确，但我们仍然可以通过缓存溢出绕开密码安全保护。</p>
<p>要避免这样的问题，建议使用 strncpy()函数。</p>
<p>此程序我用VC++6.0时候会出问题，question.exe 中的 0x54e2d2f3 (msvcr100d.dll) 处有未经处理的异常: 0xC0000005: 读取位置 0x00000000 时发生访问冲突。</p>
<p><strong>3.main()的返回类型</strong></p>
<p>问：下面的代码能 编译通过吗？如果能，它有什么潜在的问题吗？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> main(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line"> <span class="keyword">char</span> *ptr = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>);</div><div class="line"></div><div class="line"> <span class="keyword">if</span>(NULL == ptr)</div><div class="line"> {</div><div class="line"> <span class="built_in">printf</span>(<span class="string">"Malloc failed \n"</span>);</div><div class="line"> <span class="keyword">return</span>;</div><div class="line"> }</div><div class="line"> <span class="keyword">else</span></div><div class="line"> {</div><div class="line"> <span class="comment">// Do some processing</span></div><div class="line"> <span class="built_in">free</span>(ptr);</div><div class="line"> }</div><div class="line"></div><div class="line"> <span class="keyword">return</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>答：因为main()方法的返回类型，这段代码的错误在大多数编译器里会被当作警告。main()的返回类型应该是“int”而不是“void”。因为“int”返回类型会让程序返回状态值。这点非常重要，特别当程序是作为依赖于程序成功运行的脚本的一部分运行时。</p>
<p>上面代码我在win7，VC++6.0和VS2010上面测试都没问题。</p>
<p><strong>4.内存泄露</strong></p>
<p>问：下面的代码会导致内存泄漏吗？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></div><div class="line"><span class="keyword">void</span> main(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line"> <span class="keyword">char</span> *ptr = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>);</div><div class="line"></div><div class="line"> <span class="keyword">if</span>(NULL == ptr)</div><div class="line"> {</div><div class="line"> <span class="built_in">printf</span>(<span class="string">"Malloc failed \n"</span>);</div><div class="line"> <span class="keyword">return</span>;</div><div class="line"> }</div><div class="line"> <span class="keyword">else</span></div><div class="line"> {</div><div class="line"></div><div class="line"> <span class="comment">// Do some processing</span></div><div class="line"> }</div><div class="line"></div><div class="line"> <span class="keyword">return</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>答：尽管上面的代码并没有释放分配给“ptr”的内存，但并不会在程序退出后导致内存泄漏。在程序结束后，所有这个程序分配的内存都会自动被处理掉。但如果上面的代码处于一个“while循环”中，那将会导致严重的内存泄漏问题！</p>
<p><strong>5.free()函数</strong></p>
<p>问：下面的程序会在用户输入’freeze’的时候出问题，而’zebra’则不会，为什么？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</div><div class="line">{</div><div class="line"> <span class="keyword">char</span> *ptr = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>);</div><div class="line"></div><div class="line"> <span class="keyword">if</span>(NULL == ptr)</div><div class="line"> {</div><div class="line"> <span class="built_in">printf</span>(<span class="string">"Malloc failed \n"</span>);</div><div class="line"> <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line"> }</div><div class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(argc == <span class="number">1</span>)</div><div class="line"> {</div><div class="line"> <span class="built_in">printf</span>(<span class="string">"Usage \n"</span>);</div><div class="line"> }</div><div class="line"> <span class="keyword">else</span></div><div class="line"> {</div><div class="line"> <span class="built_in">memset</span>(ptr, <span class="number">0</span>, <span class="number">10</span>);</div><div class="line"></div><div class="line"> <span class="built_in">strncpy</span>(ptr, argv[<span class="number">1</span>], <span class="number">9</span>);</div><div class="line"></div><div class="line"> <span class="keyword">while</span>(*ptr != <span class="string">'z'</span>)</div><div class="line"> {</div><div class="line"> <span class="keyword">if</span>(*ptr == <span class="string">' '</span>)</div><div class="line"> <span class="keyword">break</span>;</div><div class="line"> <span class="keyword">else</span></div><div class="line"> ptr++;</div><div class="line"> }</div><div class="line"></div><div class="line"> <span class="keyword">if</span>(*ptr == <span class="string">'z'</span>)</div><div class="line"> {</div><div class="line"> <span class="built_in">printf</span>(<span class="string">"String contains 'z'\n"</span>);</div><div class="line"> <span class="comment">// Do some more processing</span></div><div class="line"> }</div><div class="line"></div><div class="line"> <span class="built_in">free</span>(ptr);</div><div class="line"> }</div><div class="line"></div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>答：这里的问题在于，代码会（通过增加“ptr”）修改while循环里“ptr”存储的地址。当输入“zebra”时，while循环会在执行前被终止，因此传给free()的变量就是传给malloc()的地址。但在“freeze”时，“ptr”存储的地址会在while循环里被修改，因此导致传给free()的地址出错，也就导致了seg-fault或者崩溃。<br>此程序我没测试，感觉有点问题，看看答案评论吧。<br><strong>6.使用_exit退出</strong></p>
<p>问：在下面的代码中，atexit()并没有被调用，为什么？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> func(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line"> <span class="built_in">printf</span>(&quot;\n Cleanup function called \n&quot;);</div><div class="line"> <span class="keyword">return</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line"> <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"></div><div class="line"> atexit(func);</div><div class="line"></div><div class="line"> <span class="keyword">for</span>(;i&lt;<span class="number">0xffffff</span>;i++);</div><div class="line"></div><div class="line"> _exit(<span class="number">0</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这是因为_exit()函数的使用，该函数并没有调用atexit()等函数清理。如果使用atexit()就应当使用exit()或者“return”与之相配合。</p>
<p><pre>我认为这道题目是考察exit()和_exit()的区别，并且上面的代码在VC环境下是有缺陷的，</pre><br>a._exit()执行后立即返回给内核，而exit()要先执行一些清除操作，然后将控制权交给内核。</p>
<p>b. 调用_exit函数时，其会关闭进程所有的文件描述符，清理内存以及其他一些内核清理函数，但不会刷新流(stdin, stdout, stderr …). exit函数是在_exit函数之上的一个封装，其会调用_exit，并在调用之前先刷新流。可以看个事例吧：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> func(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line"> <span class="built_in">printf</span>(&quot;\n Cleanup function called \n&quot;);</div><div class="line"> <span class="keyword">return</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line"> <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"></div><div class="line"> atexit(func);</div><div class="line"></div><div class="line"> <span class="keyword">for</span>(;i&lt;<span class="number">0xffffff</span>;i++);</div><div class="line"></div><div class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>&nbsp;</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">void</span> func(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line"><span class="built_in">printf</span>(&quot;\n Cleanup function called \n&quot;);</div><div class="line"><span class="keyword">return</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"></div><div class="line">atexit(func);</div><div class="line"></div><div class="line"><span class="keyword">for</span>(;i&lt;<span class="number">0xffffff</span>;i++);</div><div class="line"></div><div class="line">_exit(<span class="number">0</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>分别输出上述代码就能看出区别。</p>
<p><strong>7.void*和C结构体</strong></p>
<p>问：你能设计一个能接受任何类型的参数并返回interger（整数）结果的函数吗？</p>
<p>答：如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">int</span> func(<span class="type">void</span> *<span class="keyword">ptr</span>)</div></pre></td></tr></table></figure>

<p>如果这个函数的参数超过一个，那么这个函数应该由一个结构体来调用，这个结构体可以由需要传递参数来填充。<br><strong>8.*和++操作</strong></p>
<p>问：下面的操作会输出什么？为什么？</p>
<p>原题没啥意思，我把他改成经典的栈和常量区，即char *p = “Linux”;  和  char p[] = “Linux”; 的区别：不贴代码了，贴几张图吧。</p>
<p>注意第一个程序：因为“++”和“<em>”的优先权一样，所以“</em>ptr++”相当于“<em>(ptr++)”。即应该先执行ptr++，然后才是</em>ptr，所以操作结果是“L”。第二个结果是“i”。</p>
<p><img src="http://armsword.com/wp-content/uploads/2012/09/201209132015541.jpg" alt=""></p>
<p><img src="http://armsword.com/wp-content/uploads/2012/09/20120913201719.jpg" alt=""></p>
<p><img src="http://armsword.com/wp-content/uploads/2012/09/20120913201944.jpg" alt=""><br><img src="http://armsword.com/wp-content/uploads/2012/09/20120913202029.jpg" alt=""></p>
<p><strong>9.问：修改代码片段（或者只读代码）</strong></p>
<p>问：下面的代码段有错，你能指出来吗？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include &lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="type">int</span> main(<span class="type">void</span>)</div><div class="line">{</div><div class="line"> <span class="type">char</span> *<span class="keyword">ptr</span> = <span class="string">"Linux"</span>;</div><div class="line"> *<span class="keyword">ptr</span> = 'T';</div><div class="line"></div><div class="line"> printf(<span class="string">"\n [%s] \n"</span>, <span class="keyword">ptr</span>);</div><div class="line"></div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>答：这是因为，通过*ptr = ‘T’，会改变内存中代码段（只读代码）“Linux”的第一个字母。这个操作是无效的，因此会造成seg-fault或者崩溃。此题其实我上面已经提到了。不过为了维持原帖的完整性，我没删掉。</p>
<p><strong>10.会改变自己名字的进程</strong></p>
<p>问：你能写出一个在运行时改变自己进程名的程序吗？</p>
<p>答：参见下面这段代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string.h&gt;</span></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</div><div class="line">{</div><div class="line"> <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"> <span class="keyword">char</span> buff[<span class="number">100</span>];</div><div class="line"></div><div class="line"> <span class="built_in">memset</span>(buff,<span class="number">0</span>,<span class="keyword">sizeof</span>(buff));</div><div class="line"></div><div class="line"> <span class="built_in">strncpy</span>(buff, argv[<span class="number">0</span>], <span class="keyword">sizeof</span>(buff));</div><div class="line"> <span class="built_in">memset</span>(argv[<span class="number">0</span>],<span class="number">0</span>,<span class="built_in">strlen</span>(buff));</div><div class="line"></div><div class="line"> <span class="built_in">strncpy</span>(argv[<span class="number">0</span>], <span class="string">"NewName"</span>, <span class="number">7</span>);</div><div class="line"></div><div class="line"> <span class="comment">// Simulate a wait. Check the process</span></div><div class="line"> <span class="comment">// name at this point.</span></div><div class="line"> <span class="keyword">for</span>(;i &lt; <span class="number">0xffffffff</span>;i++);</div><div class="line"></div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我在win7+VC6.0下测试未成功，才疏学浅，一会弄明白之后，再更新。</p>
<p><strong>11.返回本地变量的地址</strong></p>
<p>问：下面代码有问题吗？如果有，该怎么修改？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span>* inc(<span class="keyword">int</span> val)</div><div class="line">{</div><div class="line"> <span class="keyword">int</span> a = val;</div><div class="line"> a++;</div><div class="line"> <span class="keyword">return</span> &a;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</div><div class="line">{</div><div class="line"> <span class="keyword">int</span> a = <span class="number">10</span>;</div><div class="line"> <span class="keyword">int</span> *val = inc(a);</div><div class="line"> <span class="built_in">printf</span>(<span class="string">"\n Incremented value is equal to [%d] \n"</span>, *val);</div><div class="line"></div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>答：尽管上面的程序有时候能够正常运行，但是在“inc()”中存在严重的漏洞。这个函数返回本地变量的地址。因为本地变量的生命周期就是“inc()”的生命周期，所以在inc结束后，使用本地变量会发生不好的结果。这可以通过将main()中变量“a”的地址来避免，这样以后还可以修改这个地址存储的值。有空拓展下该问题。</p>
<p><strong>12.处理printf()的参数</strong></p>
<p>问：下面代码会输出什么？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include &lt;stdio.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main(void)</div><div class="line">{</div><div class="line"> <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>, c = <span class="number">30</span>;</div><div class="line"> <span class="keyword">printf</span>(&quot;\n <span class="variable">%d</span>..<span class="variable">%d</span>..<span class="variable">%d</span> \n&quot;, a+b+c, (b = b*<span class="number">2</span>), (c = c*<span class="number">2</span>));</div><div class="line"></div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>答：输出结果是：110..40..60</p>
<p>这是因为C语言里函数的参数默认是从右往左处理的，输出时是从左往右。</p>
<p>虽然最后一道题目最容易理解，但是水木社区却有很多不同的声音，见链接：</p>
<p><a href="http://www.newsmth.net/nForum/#!article/CProgramming/121694?p=1" target="_blank" rel="external">http://www.newsmth.net/nForum/#!article/CProgramming/121694?p=1</a></p>
<p>所以，除了自己的无知，我一无所知。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2012-08-01T05:50:43.000Z"><a href="/2012/08/01/hello-world/">8月 1 2012</a></time>
      
      
  
    <h1 class="title"><a href="/2012/08/01/hello-world/"> 人生大病，只是一“傲”字</a></h1>
  

    </header>
    <div class="entry">
      
        <p>先生曰：“人生大病，只是一傲字。为子而傲必不孝，为臣而傲必不忠，为父而傲必不慈，为友而傲必不信。故象与丹朱俱不肖，亦只一傲字，便结果了此生。诸君常要体此人心本是天然之理，精精明明，无致介染着，只是一无我而已：胸中切不可有，有即傲也。古先圣人许多好处，也只是无我而已，无我自能谦。谦者众善之基，傲者众恶之魁。”</p>
<p>引用王阳明先生的这段话来表示下我今后的学习和生活态度，与君共勉。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



<nav id="pagination">
  
    <a href="/page/8/" class="alignleft prev">上一页</a>
  
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:armsword.com">
  </form>
</div>


  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/C-C/">C/C++</a><small>22</small></li>
  
    <li><a href="/categories/Database/">Database</a><small>2</small></li>
  
    <li><a href="/categories/Linux/">Linux</a><small>13</small></li>
  
    <li><a href="/categories/ML-NLP/">ML/NLP</a><small>3</small></li>
  
    <li><a href="/categories/Python/">Python</a><small>2</small></li>
  
    <li><a href="/categories/SDK-MFC/">SDK/MFC</a><small>3</small></li>
  
    <li><a href="/categories/我的生活/">我的生活</a><small>4</small></li>
  
    <li><a href="/categories/算法-数据结构/">算法/数据结构</a><small>4</small></li>
  
    <li><a href="/categories/计算机网络/">计算机网络</a><small>9</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2014/11/22/move-from-wordpress-to-hexo/">将WordPress迁移到hexo并同时托管到Github和Gitcafe上</a>
      </li>
    
      <li>
        <a href="/2014/11/07/finding-job-result/">一蓑烟雨任平生</a>
      </li>
    
      <li>
        <a href="/2014/10/29/tinyhttpd-code-analyse/">tinyhttpd源码剖析</a>
      </li>
    
      <li>
        <a href="/2014/10/26/webbench-source-analyse/">Webbench源码剖析</a>
      </li>
    
      <li>
        <a href="/2014/09/04/redis-ae-analyse/">Redis AE事件库源码剖析</a>
      </li>
    
      <li>
        <a href="/2014/08/30/find-the-invaded-reason/">记一次查找实验室服务器被诡异的入侵原因</a>
      </li>
    
      <li>
        <a href="/2014/08/16/gdb-search-virtual-table/">使用GDB查找虚函数表</a>
      </li>
    
  </ul>
</div>



  

  <div class="widget tag">
<h3 class="title">友情链接</h3>
<ul class="entry">
<li><a href="http://linuxer.me" target="_blank" title="armsword的涅槃之地">armsword</a></li>
<li><a href="http://yanyiwu.com" target="_blank" title="YanYi">YanYi</a></li>
<li><a href="http://blog.purplecow.me" target="_blank" title="PurpleCow">PurpleCow</a></li>
<li><a href="http://cstdlib.com" target="_blank" title="徐小夫">PurpleCow</a></li>
</ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft"> 
  
  &copy; 2014 armsword
  
  
<script type="text/javascript">
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fe638302684cdd7a8947e96306931ef83' type='text/javascript'%3E%3C/script%3E"));
</script>
</script>


</div>

<div class="clearfix"></div>
</footer>
  <script src="/js/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id="totop" style="position:fixed;bottom:30px;right:30px;cursor: pointer;">
<a title="返回顶部"><img src="/imgs/scrollup.png"/></a>
</div>

<script src="/js/totop.js"></script>


</body>
</html>