<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 5 页 | armsword的涅槃之地</title>
  <meta name="author" content="armsword">
  
  <meta name="description" content="程序员,搜索引擎,网络编程,后台开发,北邮人,阿里巴巴,神马搜索,Linux,C,C++,Python">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="armsword的涅槃之地"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="icon" type="image/x-ico"> 
  <link rel="alternate" href="/atom.xml" title="armsword的涅槃之地" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">armsword的涅槃之地</a></h1>
  <h2><a href="/">莫思身外无穷事，且读生平未见书 || 不为无益之事，何以遣有涯之生</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/about-me">About</a></li>
    
      <li><a href="/document-information">文档资料</a></li>
    
  <li><a href="/atom.xml">RSS</a><li>
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-12-04T15:21:39.000Z"><a href="/2013/12/04/kdd-note/">12月 4 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/12/04/kdd-note/">文本挖掘技术笔记</a></h1>
  

    </header>
    <div class="entry">
      
        <p>我第一次接触自然语言处理还是研一的时候，当时我读的是那本经典书籍《数学之美》，之后我就对NLP/文本挖掘/IR方向兴趣比较大，所以也一直想毕业后去搜索相关公司。但是考虑到自己的基础水平，迟迟没有深入研究，其实主要原因是我一直在补计算机类基础知识呢，因为我是比较看重基础的，现在还差编译原理了，时间不够用了，也得感叹下，要学的知识太多了。前几天双11买了本《统计自然语言处理》，打算深入的研究下，所以这2天我把北京大学的文本挖掘的课件快速的看了看，算法之类的公式推倒我没细看，主要是记录下一些知识点。</p>
<p>本人主要是给自己看的，所以比较乱，也没有逻辑可言。基本上都是关键知识点，比如一些专有名词等等。</p>
<p>一、分词</p>
<p>（1）分词基本方法</p>
<p>1.最大匹配法</p>
<p>基于其他匹配的分词方法：<br>1&gt; 最大匹配法 (Maximum Matching method)<br>匹配的方法是从左向右<br>2&gt; 逆向最大匹配法 (Reverse Maximum method)<br>匹配方向与MM法相反,是从右向左。<br>实验表明:对于汉语来说,逆向最大匹配法比最大匹配法更有效。<br>3&gt; 双向匹配法(Bi-direction Matching method)<br>比较MM法与RMM法的分词结果,从而决定正确的分词。<br>4&gt; 最佳匹配法(Optimum Matching method, OM法)<br>将词典中的单词按它们在文本中的出现频度的大小排列,高频度的单词排在前,频度低的单词排在后,从而提高匹配的速度。<br>5&gt; 联想-回溯法(Association-Backtracking method)<br>采用联想和回溯的机制来进行匹配。</p>
<p>2.最大概率法分词</p>
<p>基本思想是:<br>(1)一个待切分的汉字串可能包含多种分词结果<br>(2)将其中概率最大的那个作为该字串的分词结果</p>
<p>3.最短路径分词方法</p>
<p>基本思想:<br>在词图上选择一条词数最少的路径</p>
<p>（2）词性标注</p>
<p>自动词性标注就是用计算机来自动地给文本中的词标注词性。<br>1.标注技术路线:<br>基于概率统计和基于规则</p>
<p>（3）文档模型</p>
<p>1.布尔模型<br>2.向量空间模型（VSM）<br>3.概率模型<br>Term Weights 、Term frequency (tf) 、Inverse document frequency (idf)</p>
<p>（4）文本间相似性计算</p>
<p>1.基于概率模型的相关度<br>2.基于VSM的相关度计算方法<br>基于向量空间模型的常用方法：<br>欧氏距离(很少使用）<br>向量内积<br>向量夹角余弦<br>1&gt;余弦相似度<br>2&gt;Jaccard相似度</p>
<p>（5）文本序列</p>
<p>序列比较可以分为四种基本情况:<br>(1)两条长度相近的序列相似找出序列的差别<br>(2)一条序列是否包含另一条序列(子序列)<br>(3)两条序列中是否有非常相同的子序列<br>(4)一条序列与另一条序列逆序相似<br>相似度:它是两个序列的函数,其值越大,表示两个序列越相似<br>距离:距离越大,则两个序列的相似度就越小<br>1&gt;海明距离<br>2&gt;编辑距离<br>通过点矩阵进行序列比较</p>
<p>（6）TextTiling</p>
<p>TextTiling (Hearst and Plaunt 1993)is one of the most famous system forTopic Segmentation.(对文档分段)<br>TextTiling method:<br>1&gt;先把文档分成块(tile),每块k个句子。<br>2&gt;计算相邻块之间的相似度,用标准的文档相似度计算公式。<br>3&gt;用结果绘图。非常相似处会出现波峰,很不相似的地方出现波谷。选择波谷处作为分界线,把块组成段,这些段很可能是有关同一个Subtopic的。</p>
<p>（7）特征空间的变化</p>
<p>1&gt;Latent Semantic Analysis (LSA)<br>LSI思想方法最初应用于文本信息检索领域有效地解决了同义词和多义词的问题,通过识别文本中的同义词, LSI将信息检索精度提高了10%—30%.(查询扩展)<br>Latent Semantic Indexing (LSI)</p>
<p>基本方法:<br>利用矩阵理论中的“奇异值分解(singular value decomposition,SVD)”技术,将词频矩阵转化为奇异矩阵(K×K)<br>基本步骤:<br>1.建立词频矩阵,frequency matrix<br>2.计算frequency matrix的奇异值分解分解frequency matrix成3个矩阵U,S,V。U和V是正交矩阵(UTU=I),S是奇异值的对角矩阵(K×K)<br>3.对于每一个文档 d,用排除了SVD中消除后的词的新的向量替换原有的向量<br>4.用转换后的文档索引和相似度计算</p>
<p>（8）词频矩阵</p>
<p>词频矩阵:矩阵表示一组文档<br>1&gt;行对应关键词t,列对应文档d向量<br>2&gt;将每一个文档视为空间的一个向量<br>3&gt;向量值反映单词t与文档d的关联度</p>
<p>二、文本检索技术</p>
<p>1.基于分类的检索<br>2.基于主题词的检索<br>3.基于元数据的检索</p>
<p>1.信息检索模型:<br>IR模型可形式地表示为一个四元组&lt; D, Q, F, R(qi,dj) &gt;<br>其中:<br>D是一个文档集合,<br>Q是一个查询集合,用户任务的表达<br>F是一个框架,用以构建文档,查询以及它们之间关系的模型<br>R(qi,dj) 是一个排序函数,它给查询qi和文档 dj 之间的相关度赋予一个排序值</p>
<p>2.布尔检索模型</p>
<p>3.向量空间模型(VSM)</p>
<p>4.概率模型</p>
<p>5.语言模型<br>1&gt;一元(Unigram)模型<br>假设词与词之间是相互独立的,一个词出现的概率与这个词前面的词没有存在必然联系。 P (W 1W 2 ..W n ) = P (W 1 ) P (W 2 )… P (W n )<br>2&gt;N元(NGram)模型<br>假设词与词之间是相互关联的,一个词出现的概率与这个词前面的词存在一定的关联。<br>二元(Bigram)模型<br>P (W1W 2 ..W n ) = P (W1 ) P (W 2 | W1 )… P (W n | W n −1 )<br>N元(NGram)模型<br>P(WW2..Wn ) = P(W )P(W2 | W )… (Wn | Wn−1Wn−2..W1)</p>
<p>检索质量的评价：</p>
<p>文本检索的基本度量<br>1&gt;查准率(precision):既相关又被检索到的实际文档与检索到的文档的百分比。<br>2&gt;查全率(召回率recall):既相关又被检索到的实际文档与查询相关的文档的百分比</p>
<p>索引作用:<br>索引<br>1&gt;提供从记录的特征快速查询到记录的数据结构(B树、散列表、位图索引等)<br>2&gt;数据库,文档数据库,SE/IR系统</p>
<p>签名文件:<br>定义:是一个记录每一个文档的特征的文件<br>方法:每一个特征对应一个固定长度的位串,一个比特位对应一个词汇,若某一位对应的词出现在文档中则该位置1,否则置0。<br>按位操作进行匹配,确定文档的相似性<br>可以多词对应一个比特位,来减少位串的长度,但增加搜素开销,存在多对一映射的缺点。</p>
<p>倒排索引创建-算法优化<br>1&gt;Term编码(词典组织)<br>每个term用整数编码,减小存储空间<br>英文-前缀编码<br>(liber,liberal,liberalist…)<br>散列表(MPH,无冲突散列)<br>2&gt;减少磁盘的随机访问次数<br>&lt;termid,docid&gt;在内存中排序,排序结果分<br>批写入磁盘,最后合并。<br>两趟算法,在内存中直接倒排,小倒排文件<br>分批写入磁盘,最后多路合并。<br>3&gt;数据压缩</p>
<p>倒排索引创建-两趟算法<br>索引创建—两趟算法<br>1.Parsing ,提取index term,统计df和tf,通过hash表转换为term id,生成词典文件(lexicon file)。<br>2.按统计得到的index term的tf,df属性,可以估计出对应posting list长度,预申请空间。再次parsing文档集,在内存中执行倒排。结果保存到临时文件。<br>3.对多次生成的临时倒排文件,多路合并,压缩输出,得到最终倒排文件。</p>
<p>倒排索引创建-整数压缩</p>
<p>三、文本自动分类技术</p>
<p>文本自动分类：<br>基本步骤<br>1&gt;定义分类体系<br>2&gt;将预先分类过的文档作为训练集<br>3&gt;从训练集中得出分类模型(需要测试过程,不断细化)<br>4&gt;用训练获得出的分类模型对其它文档加以分类</p>
<p>文本分类基本步骤:<br>1. 用户定义分类树<br>2. 用户为分类节点提供训练文档<br>3. 特征选择<br>4. 训练<br>5. 自动分类</p>
<p>评价指标:<br>「准确率」(P, precision)<br>「召回率」(R, recall)</p>
<p>特征抽取<br>特征抽取(feature extraction):<br>1&gt;预处理<br>去掉html一些tag标记<br>禁用词(stop words)去除、词根还原(stemming)<br>(中文)分词、词性标注、短语识别、…<br>词频统计 (TF DF)<br>数据清洗:去掉噪声文档或文档内垃圾数据<br>2&gt;文本表示<br>向量空间模型<br>3&gt;降维技术<br>特征选择(Feature Selection)<br>特征重构(Re-parameterisation,如LSI)</p>
<p>特征选择:<br>目的<br>避免过拟合(over fitting),提高分类准确度<br>• 如果经过某种学习之后的分类模型,使得训练文档适应得很好(导致很高的自动分类精度),但对训练集之外的文档显得差许多,则称此时的学习模型有Over-fitting problem<br>• 希望模型的表现对训练集和未知文档基本一致。<br>通过降维,大大节省计算时间和空间<br>• 样例空间涉及的总词项数很大(N在10万量级),但每篇文档只涉及其中的一小部分(例如一篇网页通常只有几百个词)(到1/10 – 1/100,甚至更多)</p>
<p>特征选取的方法:<br>1&gt;文档频率法(DF, document frequency)<br>2&gt;信息增益法(information gain)<br>3&gt;互信息法(mutual information)<br>4&gt;The χ^2 test(chi-square,开方拟合检验)</p>
<p>特征选择—DF:<br>基于DF的启发式要点<br>1&gt;太频繁的词项没有区分度<br>• Term的DF大于某个阈值去掉太稀有的词项独立表达的类别信息不强<br>• 稀有词项的全局影响力不大<br>• 在训练集中,某些文档如果有某个稀有词项,它们通常也会有一些常见词项(对那一类)和通常信息获取观念有些抵触:稀有的更有代表性(这是一种ad hoc方法,不依据什么理论)<br>2&gt;最容易实现,可扩展性好</p>
<p>特征选择—RSJ:</p>
<p>特征选择—熵:<br>1&gt;设信息出现(例如“硬币出现某一面”,“一篇文档属于某一类”)的概率空间p = {p1, p2, …, pm}<br>2&gt;在引入某个词项t之前,系统的熵(即一个随机文档落入某个类的概率空间的熵)<br>3&gt;在观察到t以后,文档落入某个类ci的概率就应该是条件概率P(ci|t)<br>对应于相关表中的A/A+C<br>注意,对不同的ci,每个分量不一定相同<br>4&gt;term类别分布的熵<br>该值越大,说明分布越均匀,越有可能出现在较多的类别中;<br>该值越小,说明分布越倾斜,词可能出现在较少的类别中</p>
<p>特征选择—相对熵:<br>相对熵(not 交叉熵):也称为KL距离(Kullback-Leibler divergence)反映了文本类别的概率分布和在出现了某个特定词汇条件下的文本类别的概率分布之间的距离。<br>该值越大,词对文本类别分布的影响也大。</p>
<p>特征选择—信息增益IG<br>信息增益(Information Gain, IG):<br>该term为整个分类所能提供的信息量<br>t出现与否导致的熵的变化<br>不考虑任何特征的熵和考虑该特征后的熵的差值</p>
<p>特征选择—互信息MI：<br>1&gt;统计语言学建模的一种方法,是评估两个随机变量X, Y相关程度的一种度量。<br>2&gt;X, Y分别对应词项t的出现情况和类别的出现情况<br>3&gt;关心的P(t), P(c), P(t,c)都可以通过统计训练集中的数据情况得到</p>
<p>特征选择—χ^2 (卡方):<br>1&gt;源于统计学的卡方分布(chi-square)<br>2&gt;从(类,词项)相关表出发<br>3&gt;χ2 统计量:<br>度量两者(term和类别)独立性的缺乏程度χ2 越大,独立性越小,相关性越大若AD&lt;BC,则类和词独立, N=A+B+C+D</p>
<p>特征选择—Term强度(TS):<br>term strength<br>一种新颖的角度,考察一个词项在“相似文档”中出现的可能性<br>假定我们已经有了一个相似文档的集合S,设x, y为其中任意两个文档,那么词项t对这个集合的术语强度为s(t) = Pr(tєy|tєx)<br>S中的文档要满足一定的“相似度”指标,S不一定就是训练集中的那些类。通常由聚类来确定S。<br>分类算法:<br>1&gt;决策树(Decision Trees)<br>2&gt;KNN算法(K-Nearest Neighbour)<br>3&gt;贝叶斯网络(Bayes Network)<br>4&gt;神经网络(Neural Networks)<br>5&gt;Boosting<br>6&gt;支持向量机(SVM)</p>
<p>四、文本自动聚类技术</p>
<p>什么是聚类?<br>聚类(簇Cluster): 数据对象的集合在同一个簇中,数据对象是相似的不同簇之间的对象是不相似的。</p>
<p>什么是聚类分析?<br>聚类分析就是按照一定的规律和要求对事物进行区分和分类的过程,在这一过程中没有任何关于类分的先验知识,没有指导,仅靠事物间的相似性作为类属划分的准则。<br>一个数据集合分组成几个簇<br>聚类分析是一种无监督分类:没有预定义的类<br>聚类分析(Clustering):给定一数据样本集X{X1,X2,…,Xn},根据数据点间的相似程度将数据集合分成k簇{C1,C2,…,Ck}的过程称为聚类分析。</p>
<p>文本聚类基本步骤：<br>1.用户指定用于聚类的数据集合<br>2.特征选取<br>3.聚合: 将每个文档分配到相应的类中<br>4.标注: 给每个聚类选择关键词</p>
<p>什么是一个好的聚类方法?<br>1&gt;聚类方法的好坏:该方法是否能发现某些或所有的隐含模式;<br>一个好的聚类方法要能产生高质量的聚类结果——簇,这些簇要具备以下两个特点:<br>高的簇内相似性<br>低的簇间相似性<br>2&gt;聚类结果的好坏取决于:<br>聚类方法采用的相似性评估方法<br>该方法的具体实现;</p>
<p>聚类算法:<br>1&gt;划分方法<br>2&gt;层次方法<br>3&gt;密度方法<br>4&gt;网格方法<br>5&gt;在线聚类</p>
<p>五、话题检测跟踪技术 Topic Detection and Tracking (TDT)</p>
<p>六、文本过滤技术(IF)</p>
<p>信息过滤的定义:<br>从动态的信息流中将满足用户兴趣的信息挑选出来,用户的兴趣一般在较长一段时间内比较稳定不会改变(静态)</p>
<p>信息过滤系统的特点:<br>新信息的产生速度很快,相对来说,人的兴趣变化比较缓慢,可以看成相对静态的和稳定的。<br>信息过滤主要借用信息检索和用户建模(User modeling)两个领域的技术。<br>用户的需求或者兴趣通常采用User Profile建模来表示。<br>新信息到来的时候,根据用户的User Profile,有选择地挑出信息给用户。</p>
<p>基于内容的过滤与协同过滤</p>
<p>七、关联分析技术</p>
<p>关联规则挖掘:<br>简单的说,关联规则挖掘就是发现大量数据中项集之间有趣的关联在交易数据、关系数据或其他信息载体中,查找存在于项目集合或对象集合之间的频繁模式、关联、相关性或因果结构。</p>
<p>六和七结合起来，其实就是推荐系统，可以参考下面3篇文章。</p>
<p><a href="http://www.ibm.com/developerworks/cn/web/1103_zhaoct_recommstudy1/index.html?ca=drs-" target="_blank" rel="external">探索推荐引擎内部的秘密，第 1 部分: 推荐引擎初探</a></p>
<p><a href="http://www.ibm.com/developerworks/cn/web/1103_zhaoct_recommstudy2/index.html?ca=drs-" target="_blank" rel="external">探索推荐引擎内部的秘密，第 2 部分: 深入推荐引擎相关算法—协同过滤</a></p>
<p><a href="http://www.ibm.com/developerworks/cn/web/1103_zhaoct_recommstudy3/index.html?ca=drs-" target="_blank" rel="external">探索推荐引擎内部的秘密，第 3 部分: 深入推荐引擎相关算法—聚类</a></p>
<p>八、文档自动摘要技术</p>
<p>1&gt;提示字串法<br>2&gt;频率统计法<br>3&gt;文章框架法<br>4&gt;信息提取法<br>5&gt;理解分析法<br>6&gt;仿人算法</p>
<p>九、信息抽取</p>
<p>1&gt;实体提取<br>上下文无关实体的提取<br>• Context-Free Entity Extraction<br>2&gt;基于规则的实体提取<br>关系提取(Relational Extraction)</p>
<p>文本信息抽取的方法<br>1&gt;有限状态机<br>2&gt;Wrapper<br>3&gt;Hidden Markov Models</p>
<p>十、智能问答(QA)技术</p>
<p>主要方法<br>1&gt;Pattern-based Approach<br>2&gt;Knowledge-Based Approach<br>3&gt;Web-based Approach</p>
<p>十一、本体(Ontology)</p>
<p>给出构成相关领域词汇的基本术语和关系,以及利用这些术语和关系构成的规定这些词汇外延的规则的定义。</p>
<p>之后再放几张当时的截图吧：</p>
<p><img src="http://armsword.com/wp-content/uploads/2013/12/kdd001.png" alt=""></p>
<p><img src="http://armsword.com/wp-content/uploads/2013/12/kdd002.png" alt=""></p>
<p><img src="http://armsword.com/wp-content/uploads/2013/12/kdd005.png" alt=""></p>
<p><img src="http://armsword.com/wp-content/uploads/2013/12/kdd006.png" alt=""></p>
<p><img src="http://armsword.com/wp-content/uploads/2013/12/kdd007.png" alt=""></p>
<p><img src="http://armsword.com/wp-content/uploads/2013/12/kdd005.png" alt=""></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-11-10T15:58:57.000Z"><a href="/2013/11/10/undefined-reference-to/">11月 10 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/11/10/undefined-reference-to/">使用g++编译C/C++程序，链接时出现undefined reference to错误</a></h1>
  

    </header>
    <div class="entry">
      
        <p>题目说是g++编译C/C++程序，其实是我这个程序是C、C++混着用的，这是错误的根源，弄了几个小时才发现问题根源，记录下吧：</p>
<p>通常链接时出现 undefined reference to 错误，一般是以下原因造成的：</p>
<p>1.链接时缺失相关目标文件（.o）</p>
<p>此时，注意缺少的目标文件或者相对应.c/cpp文件是否是跟在gcc语句后面</p>
<p>2.链接时缺少相关的库文件（静态库或动态库）</p>
<p>这个一般是动态库出问题，可以用ldconfig查看下，并且gcc链接语句里要有相应的.a或.so文件。</p>
<p>3.库文件链接顺序出错</p>
<p>这个其实看函数调用顺序吧，调用函数的顺序与库文件相同。</p>
<p>4.在C++中链接C语言相关的库</p>
<p>在C++中直接调用C语言库的函数，会导致出现undefined reference to错误，这是因为C++要对函数名重新命名（与C不一样），导致找不到C语言函数，所以需要在包含的头文件里包含extern “C” 。</p>
<p>本来我以为第四种是我今天问题出现的主要原因，我在main函数里调用其他函数，出现了 undefined reference to 错误，详情如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">undefined reference to `looptopo(char*, <span class="symbol">std:</span><span class="symbol">:vector&lt</span>;<span class="symbol">std:</span><span class="symbol">:basic_string&lt</span>;char, <span class="symbol">std:</span><span class="symbol">:char_traits&lt</span>;char&gt;, <span class="symbol">std:</span><span class="symbol">:allocator&lt</span>;char&gt; &gt;, <span class="symbol">std:</span><span class="symbol">:allocator&lt</span>;<span class="symbol">std:</span><span class="symbol">:basic_string&lt</span>;char, <span class="symbol">std:</span><span class="symbol">:char_traits&lt</span>;char&gt;, <span class="symbol">std:</span><span class="symbol">:allocator&lt</span>;char&gt; &gt; &gt; &gt;&amp;, char const*)<span class="string">'</span></div></pre></td></tr></table></figure>

<p>因为我调用了mysql以及net-snmp，这些是C函数库，链接时候可能会找不到对应的函数，但是，我更改后（添加了extern “C”）也没解决，更改方法如下：</p>
<p><img src="http://armsword.com/wp-content/uploads/2013/11/201311102340.png" alt=""></p>
<p>但是，这样依然没解决问题，并且第四种如果出问题，也应该不会报我自己定义的函数未找到，后来仔细查找，终于找到了问题所在。主要原因是函数声明与定义不一致导致的：</p>
<p>头文件里声明：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> looptopo(<span class="keyword">char</span> *topoip,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;vector_type,<span class="keyword">const</span> <span class="keyword">char</span> *mib_type);</div></pre></td></tr></table></figure>

<p>函数定义：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> looptopo(<span class="keyword">char</span> *topoip,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;vector_type,<span class="keyword">char</span> *mib_type)</div><div class="line"></div><div class="line">{<span class="comment">//省略}</span></div></pre></td></tr></table></figure>

<p>你会发现头文件里函数声明，第三个参数与定义不一样，一个为const，一个为no-const，将函数定义改为如下，问题解决：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> looptopo(<span class="keyword">char</span> *topoip,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;vector_type,<span class="keyword">const</span> <span class="keyword">char</span> *mib_type)</div></pre></td></tr></table></figure>

<p>我想了想，这种情况产生的原因，因为第三个参数的实参是const类型，而声明也是const类型，所以函数编译时候是不会报错的，但是链接时候，因为C++ 是可以函数重载的，所以找不到对应的函数，导致报错。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-10-12T04:39:50.000Z"><a href="/2013/10/12/resolve-yum-problem/">10月 12 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/10/12/resolve-yum-problem/">无法使用yum安装程序的解决方法</a></h1>
  

    </header>
    <div class="entry">
      
        <p>实验室的项目做的快差不多了，昨天打算新装一台Centos机器进行下测试，师兄们先装的redis、ssh、mysql、PHP等等需要的开发包和模块，我守在最后一关，但是到我这里时候，yum不能使用了。报错内容如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">There was a problem importing one of the Python modules</div><div class="line">required to run yum. The error leading to this problem was: </div><div class="line"> </div><div class="line">/usr/lib/python2.6/site-packages/pycurl.so: undefined symbol: CRYPTO_set_locking_callback</div><div class="line"> </div><div class="line">Please <span class="operator"><span class="keyword">install</span> a package which provides this <span class="keyword">module</span>, <span class="keyword">or</span></span></div><div class="line">verify that the <span class="keyword">module</span> <span class="keyword">is</span> installed correctly.</div><div class="line"></div><div class="line">It<span class="string">'s possible that the above module doesn'</span>t <span class="keyword">match</span> the </div><div class="line"><span class="keyword">current</span> <span class="keyword">version</span> <span class="keyword">of</span> Python, which <span class="keyword">is</span>:</div><div class="line"><span class="number">2.6</span><span class="number">.6</span> (r266:<span class="number">84292</span>, <span class="built_in">Dec</span> <span class="number">7</span> <span class="number">2011</span>, <span class="number">20</span>:<span class="number">38</span>:<span class="number">36</span>) </div><div class="line">[GCC <span class="number">4.4</span><span class="number">.6</span> <span class="number">20110731</span> (Red Hat <span class="number">4.4</span><span class="number">.6</span>-<span class="number">3</span>)] </div><div class="line"> </div><div class="line"><span class="keyword">If</span> you cannot solve this problem yourself, please <span class="keyword">go</span> <span class="keyword">to</span></div><div class="line">the yum faq <span class="keyword">at</span>:</div><div class="line">http://yum.baseurl.org/wiki/Faq</div></pre></td></tr></table></figure>

<p>测试机器是Centos6 64位系统，刚开始我以为是python冲突（yum是python写的），重装了python没有解决。之后又删掉了yum，折腾了大半夜，没有解决，之后我仔细阅读了上文中的错误报告，于是使用命令：</p>
<p>ldd /usr/lib/python2.6/site-packages/pycurl.so</p>
<p>程序显示内容如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">[root@centOS6 site-packages]# ldd /usr/lib/python2.<span class="number">6</span>/site-packages/pycurl.<span class="keyword">so</span></div><div class="line">linux-gate.<span class="keyword">so</span>.<span class="number">1</span> =&gt; (<span class="number">0</span>x006da000)</div><div class="line">libcurl.<span class="keyword">so</span>.<span class="number">4</span> =&gt; /usr/lib/libcurl.<span class="keyword">so</span>.<span class="number">4</span> (<span class="number">0</span>x0065f000)</div><div class="line">libpython2.<span class="number">6</span>.<span class="keyword">so</span>.<span class="number">1.0</span> =&gt; /usr/lib/libpython2.<span class="number">6</span>.<span class="keyword">so</span>.<span class="number">1.0</span> (<span class="number">0</span>x00394000)</div><div class="line">libpthread.<span class="keyword">so</span>.<span class="number">0</span> =&gt; /lib/libpthread.<span class="keyword">so</span>.<span class="number">0</span> (<span class="number">0</span>x006f8000)</div><div class="line">libc.<span class="keyword">so</span>.<span class="number">6</span> =&gt; /lib/libc.<span class="keyword">so</span>.<span class="number">6</span> (<span class="number">0</span>x0087c000)</div><div class="line">libidn.<span class="keyword">so</span>.<span class="number">11</span> =&gt; /lib/libidn.<span class="keyword">so</span>.<span class="number">11</span> (<span class="number">0</span>x00a47000)</div><div class="line">libldap-<span class="number">2.4</span>.<span class="keyword">so</span>.<span class="number">2</span> =&gt; /lib/libldap-<span class="number">2.4</span>.<span class="keyword">so</span>.<span class="number">2</span> (<span class="number">0</span>x00110000)</div><div class="line">librt.<span class="keyword">so</span>.<span class="number">1</span> =&gt; /lib/librt.<span class="keyword">so</span>.<span class="number">1</span> (<span class="number">0</span>x00bf6000)</div><div class="line">libgssapi_krb5.<span class="keyword">so</span>.<span class="number">2</span> =&gt; /lib/libgssapi_krb5.<span class="keyword">so</span>.<span class="number">2</span> (<span class="number">0</span>x0056f000)</div><div class="line">libkrb5.<span class="keyword">so</span>.<span class="number">3</span> =&gt; /lib/libkrb5.<span class="keyword">so</span>.<span class="number">3</span> (<span class="number">0</span>x0015d000)</div><div class="line">libk5crypto.<span class="keyword">so</span>.<span class="number">3</span> =&gt; /lib/libk5crypto.<span class="keyword">so</span>.<span class="number">3</span> (<span class="number">0</span>x00fc1000)</div><div class="line">libcom_err.<span class="keyword">so</span>.<span class="number">2</span> =&gt; /lib/libcom_err.<span class="keyword">so</span>.<span class="number">2</span> (<span class="number">0</span>x00a83000)</div><div class="line">libz.<span class="keyword">so</span>.<span class="number">1</span> =&gt; /lib/libz.<span class="keyword">so</span>.<span class="number">1</span> (<span class="number">0</span>x0024f000)</div><div class="line">libssl3.<span class="keyword">so</span> =&gt; /usr/lib/libssl3.<span class="keyword">so</span> (<span class="number">0</span>x00263000)</div><div class="line">libsmime3.<span class="keyword">so</span> =&gt; /usr/lib/libsmime3.<span class="keyword">so</span> (<span class="number">0</span>x00790000)</div><div class="line">libnss3.<span class="keyword">so</span> =&gt; /usr/lib/libnss3.<span class="keyword">so</span> (<span class="number">0</span>x00a88000)</div><div class="line">libnssutil3.<span class="keyword">so</span> =&gt; /usr/lib/libnssutil3.<span class="keyword">so</span> (<span class="number">0</span>x00299000)</div><div class="line">libplds4.<span class="keyword">so</span> =&gt; /lib/libplds4.<span class="keyword">so</span> (<span class="number">0</span>x00233000)</div><div class="line">libplc4.<span class="keyword">so</span> =&gt; /lib/libplc4.<span class="keyword">so</span> (<span class="number">0</span>x00238000)</div><div class="line">libnspr4.<span class="keyword">so</span> =&gt; /lib/libnspr4.<span class="keyword">so</span> (<span class="number">0</span>x00f7e000)</div><div class="line">libdl.<span class="keyword">so</span>.<span class="number">2</span> =&gt; /lib/libdl.<span class="keyword">so</span>.<span class="number">2</span> (<span class="number">0</span>x00e34000)</div><div class="line">libssh2.<span class="keyword">so</span>.<span class="number">1</span> =&gt; /usr/local/lib/libssh2.<span class="keyword">so</span>.<span class="number">1</span> (<span class="number">0</span>x00bff000)</div><div class="line">libutil.<span class="keyword">so</span>.<span class="number">1</span> =&gt; /lib/libutil.<span class="keyword">so</span>.<span class="number">1</span> (<span class="number">0</span>x002b5000)</div><div class="line">libm.<span class="keyword">so</span>.<span class="number">6</span> =&gt; /lib/libm.<span class="keyword">so</span>.<span class="number">6</span> (<span class="number">0</span>x0032c000)</div><div class="line">/lib/ld-linux.<span class="keyword">so</span>.<span class="number">2</span> (<span class="number">0</span>x00374000)</div><div class="line">liblber-<span class="number">2.4</span>.<span class="keyword">so</span>.<span class="number">2</span> =&gt; /lib/liblber-<span class="number">2.4</span>.<span class="keyword">so</span>.<span class="number">2</span> (<span class="number">0</span>x00d8a000)</div><div class="line">libresolv.<span class="keyword">so</span>.<span class="number">2</span> =&gt; /lib/libresolv.<span class="keyword">so</span>.<span class="number">2</span> (<span class="number">0</span>x002b9000)</div><div class="line">libsasl2.<span class="keyword">so</span>.<span class="number">2</span> =&gt; /usr/lib/libsasl2.<span class="keyword">so</span>.<span class="number">2</span> (<span class="number">0</span>x002d3000)</div><div class="line">libkrb5support.<span class="keyword">so</span>.<span class="number">0</span> =&gt; /lib/libkrb5support.<span class="keyword">so</span>.<span class="number">0</span> (<span class="number">0</span>x002ee000)</div><div class="line">libkeyutils.<span class="keyword">so</span>.<span class="number">1</span> =&gt; /lib/libkeyutils.<span class="keyword">so</span>.<span class="number">1</span> (<span class="number">0</span>x00d3b000)</div><div class="line">libcrypt.<span class="keyword">so</span>.<span class="number">1</span> =&gt; /lib/libcrypt.<span class="keyword">so</span>.<span class="number">1</span> (<span class="number">0</span>x002f9000)</div><div class="line">libselinux.<span class="keyword">so</span>.<span class="number">1</span> =&gt; /lib/libselinux.<span class="keyword">so</span>.<span class="number">1</span> (<span class="number">0</span>x00a24000)</div><div class="line">libfreebl3.<span class="keyword">so</span> =&gt; /lib/libfreebl3.<span class="keyword">so</span> (<span class="number">0</span>x005ae000)</div></pre></td></tr></table></figure>

<p>我发现libssh2.so.1 =&gt; /usr/local/lib/libssh2.so.1 (0x00bff000) ，指向了/usr/local/lib。记忆中许多linux系统是默认安装ssh的。于是命令查看<br>[root@centOS6 lib]# find / -name “libssh2.so.1”<br>/usr/local/lib/libssh2.so.1<br>/usr/lib/libssh2.so.1<br>感觉应该是动态库冲突引起的yum不能使用。</p>
<p>于是编辑 vim /etc/ld.so.conf</p>
<p>include ld.so.conf.d/*.conf<br>/usr/local/lib</p>
<p>改为：</p>
<p>include ld.so.conf.d/*.conf<br>#/usr/local/lib</p>
<p>之后，再用ldconfig刷新下动态链接库，问题解决。</p>
<p>PS：可能自己程序安装的动态链接库位置在/usr/local/lib，删掉/usr/local/lib可能会影响用户自己安装程序使用。不更改ld.so.conf，建立个软链接应该可以解决。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-09-26T07:20:43.000Z"><a href="/2013/09/26/lru-cache/">9月 26 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/09/26/lru-cache/">实现一个LRU Cache</a></h1>
  

    </header>
    <div class="entry">
      
        <p>1.什么是Cache和LRU Cache</p>
<p>狭义的Cache指的是位于CPU和主存间的快速RAM， 通常它不像系统主存那样使用DRAM技术，而使用昂贵但较快速的SRAM技术。 广义上的Cache指的是位于速度相差较大的两种硬件之间， 用于协调两者数据传输速度差异的结构。除了CPU与主存之间有Cache， 内存与硬盘之间也有Cache，乃至在硬盘与网络之间也有某种意义上的Cache── 称为Internet临时文件夹或网络内容缓存等。</p>
<p>CPU中Cache能极大提高存取数据和指令的时间，让整个存储器(Cache和内存)既有Cache的高速度，又能有内存的大容量；操作系统中的内存Page中使用的Cache能使得频繁读取的内存磁盘文件较少的被置换出内存，从而提高访问速度；数据库中数据查询也用到Cache来提高效率；即便是Powerbuilder的DataWindow数据处理也用到了Cache的类似设计。</p>
<p>Cache的算法设计常见的有FIFO(first in first out)和LRU(least recently used)。LRU是Least Recently Used的缩写，意思是最近最少使用，它是一种Cache替换算法。Cache的容量有限，因此当Cache的容量用完后，而又有新的内容需要添加进来时， 就需要挑选并舍弃原有的部分内容，从而腾出空间来放新内容。LRU Cache 的替换原则就是将最近最少使用的内容替换掉。其实，LRU译成最久未使用会更形象， 因为该算法每次替换掉的就是一段时间内最久没有使用过的内容。</p>
<p>注：</p>
<p>动态随机存取存储器（Dynamic Random Access Memory，DRAM）是一种半导体存储器，主要的作用原理是利用电容内存储电荷的多寡来代表一个二进制比特（bit）是1还是0。由于在现实中电容会有漏电的现象，导致电位差不足而使记忆消失，因此除非电容经常周期性地充电，否则无法确保记忆长存。由于这种需要定时刷新的特性，因此被称为“动态”存储器。相对来说，“静态”存储器（SRAM）只要存入数据后，纵使不刷新也不会丢失记忆。</p>
<p>静态随机存取存储器（Static Random-Access Memory, SRAM）是随机存取存储器的一种。所谓的“静态”，是指这种存储器只要保持通电，里面储存的数据就可以恒常保持[1]。相对之下，动态随机存取内存（DRAM）里面所储存的数据就需要周期性地更新。然而，当电力供应停止时，SRAM储存的数据还是会消失（被称为volatile memory），这与在断电后还能储存资料的ROM或闪存是不同的。</p>
<p>下图是存储器层次结构，以前在《深入理解计算机系统》这本书看到的，顺便放到此处：</p>
<p><img src="http://armsword.com/wp-content/uploads/2013/09/20130926151041.jpg" alt=""></p>
<p>2.数据结构</p>
<p>Cache中的存储空间往往是有限的，当Cache中的存储块被用完，而需要把新的数据载入到Cache的时候，就需要设计一种良好的算法来完成数据块的替换。LRU的思想是基于“最近用到的数据被重用的概率比较早用到的大的多”这个设计规则来实现的。</p>
<p>为了能够快速删除最久没有访问的数据项和插入最新的数据项，我们双向链表连接Cache中的数据项，并且保证链表维持数据项从最近访问到最旧访问的顺序。每次数据项被查询到时，都将此数据项移动到链表头部（O(1)的时间复杂度）。这样，在进行过多次查找操作后，最近被使用过的内容就向链表的头移动，而没有被使用的内容就向链表的后面移动。当需要替换时，链表最后的位置就是最近最少被使用的数据项，我们只需要将最新的数据项放在链表头部，当Cache满时，淘汰链表最后的位置就是了。</p>
<p>注：<br>对于双向链表的使用，基于两个考虑。首先是Cache中块的命中可能是随机的，和载入进来的顺序无关。其次，双向链表插入、删除很快，可以灵活的调整相互间的次序，时间复杂度为O(1)。</p>
<p>我们要访问某个结点，就需要顺序地一个个找，时间复杂度是O(n)。使用哈希表可以让我们在O(1)的时间找到想要访问的结点，或者返回未找到。</p>
<p>所以：LRU的典型实现是双向链表和哈希表，双向链表用于存储数据结点，并且它是按照结点最近被使用的时间来存储的。哈希表用于快速访问某个结点。</p>
<p>3.一个面试题</p>
<pre><code>Question: Implement LRU <span class="operator"><span class="keyword">cache</span> algorithm 
Implement the LRU <span class="keyword">cache</span> algorithm <span class="keyword">with</span> the following interface: 
—————————————————————————————————
T <span class="keyword">get</span>(K <span class="keyword">key</span>);</span>
void put(K key, T data);
</code></pre><p>此题参考价值还是蛮大的，不少公司，特别后台开发职位会考到此题。<a href="http://hawstein.com/posts/lru-cache-impl.html" target="_blank" rel="external">hawstein</a>大牛用C++代码实现了，我们看下代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// A simple LRU cache written in C++</span></div><div class="line"><span class="comment">// Hash map + doubly linked list</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;ext/hash_map&gt;</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_cxx;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> K, <span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">struct</span> Node{</div><div class="line"> K key;</div><div class="line"> T data;</div><div class="line"> Node *prev, *next;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> K, <span class="keyword">class</span> T&gt;</div><div class="line"><span class="keyword">class</span> LRUCache{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"> LRUCache(size_t size){</div><div class="line"> entries_ = <span class="keyword">new</span> Node&lt;K,T&gt;[size];</div><div class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; size; ++i)<span class="comment">// 存储可用结点的地址</span></div><div class="line"> free_entries_.push_back(entries_+i);</div><div class="line"> head_ = <span class="keyword">new</span> Node&lt;K,T&gt;;</div><div class="line"> tail_ = <span class="keyword">new</span> Node&lt;K,T&gt;;</div><div class="line"> head_-&gt;prev = NULL;</div><div class="line"> head_-&gt;next = tail_;</div><div class="line"> tail_-&gt;prev = head_;</div><div class="line"> tail_-&gt;next = NULL;</div><div class="line"> }</div><div class="line"> ~LRUCache(){</div><div class="line"> <span class="keyword">delete</span> head_;</div><div class="line"> <span class="keyword">delete</span> tail_;</div><div class="line"> <span class="keyword">delete</span>[] entries_;</div><div class="line"> }</div><div class="line"> <span class="keyword">void</span> Put(K key, T data){</div><div class="line"> Node&lt;K,T&gt; *node = hashmap_[key];</div><div class="line"> <span class="keyword">if</span>(node){ <span class="comment">// node exists</span></div><div class="line"> detach(node);</div><div class="line"> node-&gt;data = data;</div><div class="line"> attach(node);</div><div class="line"> }</div><div class="line"> <span class="keyword">else</span>{</div><div class="line"> <span class="keyword">if</span>(free_entries_.empty()){<span class="comment">// 可用结点为空，即cache已满</span></div><div class="line"> node = tail_-&gt;prev;</div><div class="line"> detach(node);</div><div class="line"> hashmap_.erase(node-&gt;key);</div><div class="line"> }</div><div class="line"> <span class="keyword">else</span>{</div><div class="line"> node = free_entries_.back();</div><div class="line"> free_entries_.pop_back();</div><div class="line"> }</div><div class="line"> node-&gt;key = key;</div><div class="line"> node-&gt;data = data;</div><div class="line"> hashmap_[key] = node;</div><div class="line"> attach(node);</div><div class="line"> }</div><div class="line"> }</div><div class="line"> T Get(K key){</div><div class="line"> Node&lt;K,T&gt; *node = hashmap_[key];</div><div class="line"> <span class="keyword">if</span>(node){</div><div class="line"> detach(node);</div><div class="line"> attach(node);</div><div class="line"> <span class="keyword">return</span> node-&gt;data;</div><div class="line"> }</div><div class="line"> <span class="keyword">else</span>{<span class="comment">// 如果cache中没有，返回T的默认值。与hashmap行为一致</span></div><div class="line"> <span class="keyword">return</span> T();</div><div class="line"> }</div><div class="line"> }</div><div class="line"><span class="keyword">private</span>:</div><div class="line"> <span class="comment">// 分离结点</span></div><div class="line"> <span class="keyword">void</span> detach(Node&lt;K,T&gt;* node){</div><div class="line"> node-&gt;prev-&gt;next = node-&gt;next;</div><div class="line"> node-&gt;next-&gt;prev = node-&gt;prev;</div><div class="line"> }</div><div class="line"> <span class="comment">// 将结点插入头部</span></div><div class="line"> <span class="keyword">void</span> attach(Node&lt;K,T&gt;* node){</div><div class="line"> node-&gt;prev = head_;</div><div class="line"> node-&gt;next = head_-&gt;next;</div><div class="line"> head_-&gt;next = node;</div><div class="line"> node-&gt;next-&gt;prev = node;</div><div class="line"> }</div><div class="line"><span class="keyword">private</span>:</div><div class="line"> hash_map&lt;K, Node&lt;K,T&gt;* &gt; hashmap_;</div><div class="line"> <span class="stl_container"><span class="built_in">vector</span>&lt;Node&lt;K,T&gt;</span>* &gt; free_entries_; <span class="comment">// 存储可用结点的地址</span></div><div class="line"> Node&lt;K,T&gt; *head_, *tail_;</div><div class="line"> Node&lt;K,T&gt; *entries_; <span class="comment">// 双向链表中的结点</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">int</span> main(){</div><div class="line"> hash_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</div><div class="line"> <span class="built_in">map</span>[<span class="number">9</span>]= <span class="number">999</span>;</div><div class="line"> <span class="built_in">cout</span>&lt;&lt;<span class="built_in">map</span>[<span class="number">9</span>]&lt;&lt;endl;</div><div class="line"> <span class="built_in">cout</span>&lt;&lt;<span class="built_in">map</span>[<span class="number">10</span>]&lt;&lt;endl;</div><div class="line"> LRUCache&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; lru_cache(<span class="number">100</span>);</div><div class="line"> lru_cache.Put(<span class="number">1</span>, <span class="string">"one"</span>);</div><div class="line"> <span class="built_in">cout</span>&lt;&lt;lru_cache.Get(<span class="number">1</span>)&lt;&lt;endl;</div><div class="line"> <span class="keyword">if</span>(lru_cache.Get(<span class="number">2</span>) == <span class="string">""</span>)</div><div class="line"> lru_cache.Put(<span class="number">2</span>, <span class="string">"two"</span>);</div><div class="line"> <span class="built_in">cout</span>&lt;&lt;lru_cache.Get(<span class="number">2</span>);</div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>看到此处，我就想研究下redis和memcache的cache是怎么设计的了。等下次研究完后，再做下笔记吧。</p>
<p>参考链接：</p>
<p><a href="http://www.cs.uml.edu/~jlu1/doc/codes/lruCache.html" target="_blank" rel="external">http://www.cs.uml.edu/~jlu1/doc/codes/lruCache.html</a></p>
<p><a href="http://hawstein.com/posts/lru-cache-impl.html" target="_blank" rel="external">http://hawstein.com/posts/lru-cache-impl.html</a></p>
<p><a href="http://blog.csdn.net/hexinuaa/article/details/6630384" target="_blank" rel="external">http://blog.csdn.net/hexinuaa/article/details/6630384</a></p>
<p>&nbsp;</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-09-25T03:21:25.000Z"><a href="/2013/09/25/the-this-pointer/">9月 25 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/09/25/the-this-pointer/">[翻译]The This Pointer</a></h1>
  

    </header>
    <div class="entry">
      
        <p>原帖：<a href="http://www.bogotobogo.com/cplusplus/this_pointer.php" target="_blank" rel="external">http://www.bogotobogo.com/cplusplus/this_pointer.php</a></p>
<p>1.this指针</p>
<p>当我开始学习C++的时候，其中一个最大的问题就是，”this”到底是什么玩意？<br>原来这是一种特殊的指针。</p>
<p>为了确保对成员函数的类成员的指针访问，this指针存储类实例的地址。这对于刚入行的程序员来说是个不太显眼的秘密——this指针是问题的关键：<br>C++怎么知道它被调用哪个对象？<br>答案是C++有一个隐藏的被称作this的指针！</p>
<p>假如我们创建一个名为objA的类A对象，类A有一个非静态的成员函数 void f()。如果你调用objA.f()，f()里面的关键字this存储objA的地址。类A的成员函数的this指针是 A* const 类型。</p>
<p>所以，当我们调用f()，事实上我们调用的是 f(&amp;objA)。由于C++转换函数调用，它也需要转换函数本身：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">void</span> <span class="tag">A</span><span class="pseudo">::f()</span> <span class="rules">{ <span class="rule">}</span></span></div></pre></td></tr></table></figure>

<p>内部转化为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> A::f(A* <span class="keyword">const</span> <span class="keyword">this</span>);</div></pre></td></tr></table></figure>

<p>C++在函数里增加了一个新的参数。增加的参数是一个指针，指向类对象，此对象类函数正在处理。它总是被命名为this。类指针在每个类成员函数里面是一个隐藏的指针并指向类对象。作为一个结果，一个对象的this指针不是对象它自己的一部分；它并没有反映在对象上的 sizeof 语句的结果上。相反，当为对象调用非静态成员函数时，对象的地址是由编译器作为隐藏参数传递给该函数。</p>
<p>我们拿一个具体的例子看下。这是一个简单的计算器代码，用在比较亚马逊的订单和结帐上。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> Cart {</div><div class="line"><span class="keyword">private</span>:</div><div class="line"> <span class="keyword">int</span> total;</div><div class="line"><span class="keyword">public</span>:</div><div class="line"> Cart(<span class="keyword">int</span> item){</div><div class="line"> <span class="keyword">this</span>-&gt;total = item;</div><div class="line"> }</div><div class="line"> Cart&amp; addItem(<span class="keyword">int</span> itemPrice) {</div><div class="line"> total += itemPrice;</div><div class="line"> <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line"> }</div><div class="line"> <span class="keyword">void</span> checkOut() {</div><div class="line"> std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"total: "</span> &lt;&lt; total &lt;&lt; <span class="string">" $\n"</span>;</div><div class="line"> }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">{</div><div class="line"> Cart myCart(<span class="number">0</span>);</div><div class="line"> myCart.addItem(<span class="number">100</span>);</div><div class="line"> myCart.checkOut();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>按照这个代码，当我们调用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myCart.addItem(100);</div></pre></td></tr></table></figure>

<p>事实上我们调用一个被编译器转化的函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myCart.addItem(&amp;myCart, 100);</div></pre></td></tr></table></figure>

<p>这个函数从：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Cart&amp; addItem(<span class="keyword">int</span> itemPrice) {</div><div class="line"> total += itemPrice;</div><div class="line"> <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>转换为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Cart&amp; addItem(myCart* <span class="keyword">const</span> <span class="keyword">this</span>, <span class="keyword">int</span> itemPrice) {</div><div class="line"> <span class="keyword">this</span>-&gt;total += itemPrice;</div><div class="line"> <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意到下面的表达式是相等的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>-&gt;total;</div><div class="line">(*<span class="keyword">this</span>).total;</div></pre></td></tr></table></figure>

<p>返回类型是一个引用，这意味着返回的对象是调用对象本身 （myCart），而不是通过返回机制传递一份副本。<br>在main()里，我们没有利用返回的对象。如果我们稍微更改下main函数(addItem)，我们可以增加尽可能多的条目。下面是代码。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;;</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> Cart {</div><div class="line"><span class="keyword">private</span>:</div><div class="line"> <span class="keyword">int</span> total;</div><div class="line"><span class="keyword">public</span>:</div><div class="line"> Cart(<span class="keyword">int</span> item){</div><div class="line"> <span class="keyword">this</span>-&gt;total = item;</div><div class="line"> }</div><div class="line"> Cart&amp; addItem(<span class="keyword">int</span> itemPrice) {</div><div class="line"> total += itemPrice;</div><div class="line"> <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line"> }</div><div class="line"> <span class="keyword">void</span> checkOut() {</div><div class="line"> std::<span class="built_in">cout</span> &lt;&lt; <span class="string">"total: "</span> &lt;&lt; total &lt;&lt; <span class="string">" $\n"</span>;</div><div class="line"></div><div class="line"> }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">{</div><div class="line"> Cart myCart(<span class="number">0</span>);</div><div class="line"> myCart.addItem(<span class="number">100</span>).addItem(<span class="number">200</span>).addItem(<span class="number">300</span>);</div><div class="line"> myCart.checkOut();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出是简单的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">total</span>: <span class="string">600 $</span></div></pre></td></tr></table></figure>

<p>2.指针常量</p>
<p>值得注意的是，this是个常量指针：我们能够改变它指向的对象的值，但是我们不能再使它指向其他值！所以，我们不能声明此指针或者赋值给它。</p>
<p>如果成员函数被const修饰，类A的成员函数的this指针类型为const A * const。</p>
<p>const指针只能被用作const成员函数。类的数据成员在此函数中将会是常量。函数仍然能改变此值，但是需要一个const_cast：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> A::f() <span class="keyword">const</span>{</div><div class="line">member = <span class="number">2010</span>: <span class="comment">// illegal</span></div><div class="line"><span class="keyword">const_cast</span> &lt;<span class="keyword">int</span>&amp;&gt; (member) =<span class="number">2010</span>; <span class="comment">// a bad practice but legal</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>更好的技术方法是使用mutable。如果成员函数被volatile修饰，类A的成员函数的this指针的类型是 volatile A* const。例如，下面的语句，编译器是不会允许的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>{</div><div class="line"> <span class="keyword">int</span> n;</div><div class="line"> <span class="keyword">int</span> f() <span class="keyword">const</span> { <span class="keyword">return</span> n++; }</div><div class="line">};</div></pre></td></tr></table></figure>

<p>在f()函数体里，编译器不会允许n++这种声明。在f()函数里，this指针是一个 A* const 类型。函数f()尝试更改this指针指向的部分对象。</p>
<p>this指针也可以防止自我引用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (&amp;<span class="constant">Object</span> != this) {</div><div class="line"><span class="regexp">//</span> <span class="keyword">do</span> <span class="keyword">not</span> execute <span class="keyword">in</span> cases of <span class="keyword">self</span>-reference</div></pre></td></tr></table></figure>

<p>3.参数匹配</p>
<p>根据是否它们声明为静态，类成员函数是以不同的方式处理。因为非静态函数具有一个隐式参数提供this指针，非静态函数比静态函数要多一个参数。此外，它们的声明是相同的。</p>
<p>这些非静态成员函数需要隐藏的this指针匹配对象类型，包括函数调用，操作符重载，它们需要的第一个参数匹配将运算符应用于该对象。</p>
<p>不同于其他重载函数中的参数，当试图匹配this指针参数时候，没有临时对象被引入，也没有尝试被转换。</p>
<p>操作符-&gt;被用作访问成员函数，this指针参数是一个 class-name <em> const 类型。如果成员被const或volatile修饰，类型就会分别为 const class-name</em> const 类型和 volatile class-name * const 类型。</p>
<p>操作符 . 也是相同的工作方式，只是一个隐式的&amp;（取地址）操作符用作对象名称的前缀。</p>
<p>如果我按照下面这种写代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj.<span class="property">name</span></div></pre></td></tr></table></figure>

<p>编译器内部把它这样对待：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="params">(&obj)</span>-&gt;</span>name</div></pre></td></tr></table></figure>

<p>4.在构造函数中使用this</p>
<p>我们能够在构造函数内部使用this指针吗？</p>
<p>答案是肯定的。我们问这个问题是因为当我们在构造函数里使用this指针，对象还没有完全形成。然而，如果我们足够小心，我们可以使用在构造函数里使用this(在正文里)，甚至初始化列表里。</p>
<p>以下是总是成立的：构造函数的正文部分（或者从构造函数里调用的函数）可以可靠地访问基类中声明的数据成员和构造函数的类中声明的数据成员。那个因为在构造函数(正文)部分开始执行时，那些数据成员保证能够完全构造。</p>
<p>当我们必须处理虚方式时候，事情就变的复杂了。</p>
<p>5.删除this指针</p>
<p>删除this指针？</p>
<p>没有创造性的思维会做它。只有具有破坏性的头脑会尝试。</p>
<p>无论如何，我认为它不会工作。即使在析构函数里。它可能像删除空指针一样。我试图用我的 Visual Studio，总是崩溃。</p>
<p>根本的问题是既然我们仅仅能够删除堆上（自由存储区）里的对象，我们怎么能辨别出这些堆内存的位置。</p>
<p>Scott Meyers的”More Effective C++ 35 New Ways …”书里总结到，毕竟，我们不知道地址什么时候在堆上，所以也不知道什么时候不在堆上。因为我们不能，所以不能，好吧。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-09-22T12:37:50.000Z"><a href="/2013/09/22/the-virtual-table/">9月 22 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/09/22/the-virtual-table/">[翻译]The Virtual Table</a></h1>
  

    </header>
    <div class="entry">
      
        <p>看到一篇文章里面很详细的介绍了虚函数表，所以，自己翻译了下，正好当作记忆和整理思路用了。翻译的好差，自己凑合看吧~<br>原帖：<a href="http://www.learncpp.com/cpp-tutorial/125-the-virtual-table/" target="_blank" rel="external">http://www.learncpp.com/cpp-tutorial/125-the-virtual-table/</a></p>
<p>为了实现虚函数，C++使用一种特殊的后期绑定机制，这种机制被称作虚表。虚表是一种查找函数表，它被用来解决一种被称作动态/后期绑定方式的函数。虚表有时候被命名为其他名字，比如”vtable”,”virtual function table”（虚函数表）,”virtual method table”,或者”dispatch table”。</p>
<p>虚函数表事实上是非常简单的，尽管用文字来表述稍微有点困难。首先，每个使用虚函数的类（或者从使用虚函数的类派生）被给予它自己的虚函数表。这个表只是一个简单的静态数组，编译器在编译期创建此数组。虚函数表包含虚函数的入口，它可以被类的对象调用。表中的每个入口是简单的函数指针，指向类的可访问派生函数。</p>
<p>第二，编译器也在基类中增加了一个被称作 <em>__vptr 的隐藏指针。当一个类的实例被创建吼，</em><strong>vptr就被（自动）创建，所以它指向类的虚函数表。不像<em>this指针（这是一个被编译器用来指向自己的函数指针），</em></strong>vptr是一个真实的指针。所以，它使每个类对象被分配一个指针的大小。这已意味着*__vptr被派生类继承，这是非常重要的。</p>
<p>现在，你可能会疑惑如何把这些东西组合在一起，所以，我们看一个简单的例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Base</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function1</span>() {};</div><div class="line"> <span class="keyword">virtual</span> <span class="keyword">void</span> function2() {};</div><div class="line">};</div><div class="line"></div><div class="line">class D1: <span class="keyword">public</span> Base</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function1</span>() {};</div><div class="line">};</div><div class="line"></div><div class="line">class D2: <span class="keyword">public</span> Base</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function2</span>() {};</div><div class="line">};</div></pre></td></tr></table></figure>

<p>因为此处有三个类，编译器会创建三个虚函数表：一个是基类的，另一个是D1，最后一个是D2的。</p>
<p>编译器也在使用了虚函数的基类中增加了一个隐藏的指针。尽管编译器自动完成这个步骤，我们在下一个示例中增加这些代码，仅仅就是为了显示哪里增加的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Base</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"> FunctionPointer *__vptr;</div><div class="line"> <span class="keyword">virtual</span> <span class="keyword">void</span> function1() {};</div><div class="line"> <span class="keyword">virtual</span> <span class="keyword">void</span> function2() {};</div><div class="line">};</div><div class="line"></div><div class="line">class D1: <span class="keyword">public</span> Base</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function1</span>() {};</div><div class="line">};</div><div class="line"></div><div class="line">class D2: <span class="keyword">public</span> Base</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">function2</span>() {};</div><div class="line">};</div></pre></td></tr></table></figure>

<p>当一个类对象被创建后，<em>__vptr被设置为指向类的虚函数表。例如，当一个基类的对象被创建后，</em><strong>vptr被设置指向基类的虚函数表。当D1或D2类型的对象被构造后，*</strong>vptr分别被设置为指向D1或D2的虚函数表。</p>
<p>现在，我们讨论下这些虚函数表是怎么被填写的。因为此处仅仅有两个虚函数，每个虚函数表有两个进口（一个是function1()，另一个是function2()）。记住，当这些虚函数表被填写的时候，每个入口被填充了派生的函数。</p>
<p>基类的虚函数表比较简单。基类的对象仅仅可以访问基类的成员变量。基类没有访问D1和D2函数的权限。因此，function1的入口指向Base::function1()，function2的入口指向Base::function2()。</p>
<p>D1的虚函数表稍微复杂些。D1的对象能够访问D1和基类的成员。然而，D1覆盖了function1()，使D1::function1()成为派生函数，而不是base::function1()。所以，function1的入口指向D1::function1()。D1没有覆盖function2()，所以function2的入口将会指向Base::function2()。</p>
<p>D2的虚函数表与D1相似，除了function1的入口指向Base::function1()，function2的入口指向D2::function2()。</p>
<p>如下图所示：</p>
<p><img src="http://armsword.com/wp-content/uploads/2013/09/VTable.jpg" alt=""></p>
<p>尽管这个图看起来有点糟糕，但是它确实相当简单：每个类的*__vptr指向它的虚函数表。指向那个类的函数对象的底层派生版本的虚函数入口被允许调用。</p>
<p>考虑下，当我们创建D1类型的对象时候，什么将会发生：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="title">int</span> main()</div><div class="line">{</div><div class="line"> <span class="title">D1</span> cClass;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>因为cClass是一个D1的对象，cClass使它的*__vptr指向D1的虚函数表。</p>
<p>现在，我们设置一个基指针指向D1：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">int main()</span></div><div class="line">{</div><div class="line"> D1 cClass;</div><div class="line"> Base *pClass =<span class="string"> &amp;cClass;</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意到，因为pClass是一个基指针，它仅仅指向cClass的基类部分。然而，我们也注意到*<strong>vptr是在此类的基类部分，所以pClass有访问此指针的权利。最后，注意到pClass-&gt;</strong>vptr指向D1的虚函数表。所以，尽管pClass是基类型，它仍然有访问D1虚函数表的权利。</p>
<p>当我尝试访问pClass-&gt;function1()，什么会发生？</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main()</div><div class="line">{</div><div class="line"> D1 cClass;</div><div class="line"> Base *pClass = &amp;cClass;</div><div class="line"> pClass-&<span class="keyword">gt</span>;function1();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>首先，程序辨认出function1()是一个虚函数。第二，使用pClass-&gt;__vptr得到D1的虚函数表。第三，它在D1的虚函数表里寻找该调用function1()哪个版本。这个已经被D1::function1()设置。因此，pClass-&gt;function1()解析为D1::function1()！</p>
<p>现在你可能会说，如果基类指向一个基类对象，而不是一个D1对象。它会仍然调用D1::function1()吗？这个答案为 NO！</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main()</div><div class="line">{</div><div class="line"> Base cClass;</div><div class="line"> Base *pClass = &amp;cClass;</div><div class="line"> pClass-&<span class="keyword">gt</span>;function1();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个例子中，当cClass被创建后，<strong>vptr指向一个基类的虚函数表，而不是D1的虚函数表。所以，pClass-&gt;</strong>vptr 将会指向基类的虚函数表。基类的function1()的虚函数表入口指向Base::function1()。因此，pClass-function1()解析为Base::function1()。</p>
<p>使用这些表，编译器和程序能够保证函数调用解析为恰当的虚函数，甚至你仅仅使用一个指向基类的指针或引用。</p>
<p>调用一个虚函数比调用非虚函数要慢的多，有两种原因：首先，我们必须使用*__vptr来得到前挡的虚函数表。第二，我们必须索引虚函数表来找到并调用正确的函数。只有这样我们才能调用函数。结果，与正常非直接函数的两步调用，或者直接函数的一步调用，我们必须三步操作才找到函数并调用。然而，对于现在的计算机来说，这增加的时间通常是微不足道的。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-09-14T14:20:46.000Z"><a href="/2013/09/14/io-synchronous-and-blocking/">9月 14 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/09/14/io-synchronous-and-blocking/">IO模型以及同步、异步与阻塞、非阻塞的区别</a></h1>
  

    </header>
    <div class="entry">
      
        <p>1.同步、异步：你总是做完一件再去做另一件，不管是否需要时间等待，这就是同步；异步呢则反之，你可以同时做几件事，并非一定需要一件事做完再做另一件事。同步简单理解成一问一答同步进行，异步可以简单理解为不必等一个问题有答了再去问另一个问题，尽管问，有答了再通知你。<br>在实际的程序中：<br>同步消息通知机制：就好比简单的read/write 操作,它们需要等待这两个操作成功才能返回。<br>同步, 是由处理消息者自己去等待消息是否被触发。<br>异步消息通知机制：类似于select/poll 之类的多路复用IO 操作，当所关注的消息被触发时,由消息触发机制通知触发对消息的处理。<br>异步, 由触发机制来通知处理消息者。</p>
<p>2.阻塞、非阻塞：阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。非阻塞：指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。可以简单理解为需要做一件事能不能立即得到返回应答，如果不能立即获得返回，需要等待，那就阻塞了，否则就可以理解为非阻塞。<br>有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。<br>对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。<br>socket接收数据函数recv是一个阻塞调用的例子。<br>当socket工作在阻塞模式的时候， 如果没有数据的情况下调用该函数，则当前线程就会被挂起，直到有数据为止</p>
<p>3.Unix网络编程中说到：<br>将IO模型分为五类：阻塞IO，非阻塞IO，IO复用，信号驱动，异步IO。<br>基本 Linux I/O 模型的简单矩阵：</p>
<p><img src="http://armsword.com/wp-content/uploads/2013/09/figure1.gif" alt=""><br>阻塞I/O模型：<br>最流行的I/O模型是阻塞I/O模型，缺省情形下，所有文件操作都是阻塞的。我们以套接口为例来讲解此模型。在进程空间中调用recvfrom，其系统调用直到数据报到达且被拷贝到应用进程的缓冲区中或者发生错误才返回，期间一直在等待。我们就说进程在从调用recvfrom开始到它返回的整段时间内是被阻塞的。<br><img src="http://armsword.com/wp-content/uploads/2013/09/201391401.jpg" alt=""><br>非阻塞I/O模型：<br>进程把一个套接口设置成非阻塞是在通知内核：当所请求的I/O操作不能满足要求时候，不把本进程投入睡眠，而是返回一个错误。也就是说当数据没有到达时并不等待，而是以一个错误返回。<br><img src="http://armsword.com/wp-content/uploads/2013/09/201309142.jpg" alt=""><br>I/O复用模型：<br>linux提供select/poll，进程通过将一个或多个fd传递给select或poll系统调用，阻塞在select；这样select/poll可以帮我们侦测许多fd是否就绪。但是select/poll是顺序扫描fd是否就绪，而且支持的fd数量有限。linux还提供了一个epoll系统调用，epoll是基于事件驱动方式，而不是顺序扫描,当有fd就绪时，立即回调函数rollback；<br><img src="http://armsword.com/wp-content/uploads/2013/09/201309143.jpg" alt=""><br>信号驱动异步I/O模型：<br>首先开启套接口信号驱动I/O功能, 并通过系统调用sigaction安装一个信号处理函数（此系统调用立即返回，进程继续工作，它是非阻塞的）。当数据报准备好被读时，就为该进程生成一个SIGIO信号。随即可以在信号处理程序中调用recvfrom来读数据报，井通知主循环数据已准备好被处理中。也可以通知主循环，让它来读数据报。<br><img src="http://armsword.com/wp-content/uploads/2013/09/201309144.jpg" alt=""><br>异步I/O模型（AIO模型）：<br>告知内核启动某个操作，并让内核在整个操作完成后(包括将数据从内核拷贝到用户自己的缓冲区)通知我们。这种模型与信号驱动模型的主要区别是：信号驱动I/O：由内核通知我们何时可以启动一个I/O操作；异步I/O模型：由内核通知我们I/O操作何时完成。<br><img src="http://armsword.com/wp-content/uploads/2013/09/201309145.jpg" alt=""><br>具体的可以查看参考链接(2)。</p>
<p>4.通常，我们写服务器处理模型的程序时，有以下几种模型：<br>（1）每收到一个请求，创建一个新的进程，来处理该请求；<br>（2）每收到一个请求，创建一个新的线程，来处理该请求；<br>（3）每收到一个请求，放入一个事件列表，让主进程通过非阻塞I/O方式来处理请求<br>上面的几种方式，各有千秋，<br>第（1）中方法，由于创建新的进程的开销比较大，所以，会导致服务器性能比较差,但实现比较简单。<br>第（2）种方式，由于要涉及到线程的同步，有可能会面临死锁等问题。<br>第（3）种方式，在写应用程序代码时，逻辑比前面两种都复杂。<br>综合考虑各方面因素，一般普遍认为第（3）种方式是大多数网络服务器采用的方式，这也是接下来要讨论的重点—事件驱动处理库。</p>
<p>select 模型：<br>①最大并发数限制，因为一个进程所打开的 FD（文件描述符）是有限制的，由 FD_SETSIZE 设置，默认值是1024/2048，因此Select模型的最大并发数就被相应限制了。<br>②效率问题，select 每次调用都会线性扫描全部的FD集合这样效率就会呈现线性下降，把 FD_SETSIZE 改大的后果就是，大家都慢慢来，什么？都超时了。<br>③内核/用户空间内存拷贝问题，如何让内核把FD消息通知给用户空间呢？在这个问题上select 采取了内存拷贝方法。</p>
<p>总结为：1.连接数受限 2.查找配对速度慢 3.数据由内核拷贝到用户态</p>
<p>poll 模型：<br>基本上效率和select是相同的，select缺点的②和③它都没有改掉。</p>
<p>epoll模型：<br>①epoll没有最大并发连接的限制，上限是最大可以打开文件的数目，这个数字一般远大于 2048, 一般来说这个数目和系统内存关系很大 ，具体数目可以 cat /proc/sys/fs/file-max 察看。</p>
<p>②效率提升，epoll最大的优点就在于它只管你“活跃”的连接,而跟连接总数无关，因此在实际的网络环境中,epoll 的效率就会远远高于select和poll。</p>
<p>③内存拷贝,epoll在这点上使用了“共享内存”,这个内存拷贝也省略了。</p>
<p>参考链接：<br>(1)《怎样理解阻塞非阻塞与同步异步的区别》<a href="http://www.zhihu.com/question/19732473" target="_blank" rel="external">http://www.zhihu.com/question/19732473</a><br>(2)《Unix Network Programming Vol1 1002003, 3Ed》 <a href="http://english.tebyan.net/newindex.aspx?pid=31159&amp;BookID=23760&amp;PageIndex=92&amp;Language=3" target="_blank" rel="external">http://english.tebyan.net/newindex.aspx?pid=31159&amp;BookID=23760&amp;PageIndex=92&amp;Language=3</a><br>(3)<a href="http://blog.chinaunix.net/uid-26000296-id-3754118.html" target="_blank" rel="external">http://blog.chinaunix.net/uid-26000296-id-3754118.html</a><br>(4)<a href="http://blog.csdn.net/colzer/article/details/8169075" target="_blank" rel="external">http://blog.csdn.net/colzer/article/details/8169075</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



<nav id="pagination">
  
    <a href="/page/4/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/6/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:armsword.com">
  </form>
</div>


  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/C-C/">C/C++</a><small>23</small></li>
  
    <li><a href="/categories/Database/">Database</a><small>2</small></li>
  
    <li><a href="/categories/Linux/">Linux</a><small>14</small></li>
  
    <li><a href="/categories/ML-NLP/">ML/NLP</a><small>3</small></li>
  
    <li><a href="/categories/Web-Script/">Web/Script</a><small>4</small></li>
  
    <li><a href="/categories/Windows/">Windows</a><small>3</small></li>
  
    <li><a href="/categories/我的生活/">我的生活</a><small>3</small></li>
  
    <li><a href="/categories/算法-数据结构/">算法/数据结构</a><small>4</small></li>
  
    <li><a href="/categories/计算机网络/">计算机网络</a><small>8</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2015/01/31/baidu-lossless-music-downloader/">写了一个Chrome插件 - 百度无损音乐下载插件</a>
      </li>
    
      <li>
        <a href="/2015/01/26/jwsmtp-analyse/">jwSMTP源码剖析</a>
      </li>
    
      <li>
        <a href="/2014/12/01/learn-emacs-note/">Emacs学习笔记</a>
      </li>
    
      <li>
        <a href="/2014/11/22/move-from-wordpress-to-hexo/">将WordPress迁移到hexo并同时托管到Github和Gitcafe上</a>
      </li>
    
      <li>
        <a href="/2014/11/07/finding-job-result/">一蓑烟雨任平生</a>
      </li>
    
      <li>
        <a href="/2014/10/29/tinyhttpd-code-analyse/">tinyhttpd源码剖析</a>
      </li>
    
      <li>
        <a href="/2014/10/26/webbench-source-analyse/">Webbench源码剖析</a>
      </li>
    
  </ul>
</div>



  

  <div class="widget tag">
<h3 class="title">友情链接</h3>
<ul class="entry">
<li><a href="http://linuxer.me" target="_blank" title="armsword的涅槃之地">armsword</a></li>
<li><a href="http://yanyiwu.com" target="_blank" title="YanYi">YanYi</a></li>
<li><a href="http://dreamshield.net/" target="_blank" title="DreamShield">DreamShield</a></li>
<li><a href="http://blog.purplecow.me" target="_blank" title="PurpleCow">PurpleCow</a></li>
<li><a href="http://cstdlib.com" target="_blank" title="徐小夫">徐小夫</a></li>
</ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft"> 
  
  &copy; 2015 armsword
  
  || 
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253622272'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253622272' type='text/javascript'%3E%3C/script%3E"));</script>

 
</div>
<div class="clearfix"></div>
</footer>
  <script src="/js/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id="totop" style="position:fixed;bottom:30px;right:30px;cursor: pointer;">
<a title="返回顶部"><img src="/imgs/scrollup.png"/></a>
</div>

<script src="/js/totop.js"></script>


</body>
</html>