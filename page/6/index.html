<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 6 页 | armsword的涅槃之地</title>
  <meta name="author" content="armsword">
  
  <meta name="description" content="程序员,搜索引擎,网络编程,后台开发,北邮人,阿里巴巴,神马搜索,Linux,C,C++,Python">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="armsword的涅槃之地"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.ico" rel="icon" type="image/x-ico"> 
  <link rel="alternate" href="/atom.xml" title="armsword的涅槃之地" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">armsword的涅槃之地</a></h1>
  <h2><a href="/">莫思身外无穷事，且读生平未见书 || 不为无益之事，何以遣有涯之生</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="/about-me">About</a></li>
    
      <li><a href="/document-information">文档资料</a></li>
    
  <li><a href="/atom.xml">RSS</a><li>
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-09-07T11:51:53.000Z"><a href="/2013/09/07/offer/">9月 7 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/09/07/offer/">看了点《剑指offer》</a></h1>
  

    </header>
    <div class="entry">
      
        <p>早就听说，《剑指offer》这本书特别赞，对于马上要找工作的同学（技术岗）帮助特别大，今天随便翻了几十页，这本书确实值得读一读，比如一些简单的程序，这本书会提示你别忘记考虑边界条件，特殊情况，比如判断指针为空，字符串长度为0情况以及错误处理方面，还多次提到别忘记写test case，还有一些问题答案虽然很简单，但是其解释特别详细，原理也说的很明白。当然参加过ACM的同学这本书可能就意义不是太大了。这里简单记录下几道入门题目：</p>
<p>1.C++里定义一个空的类型，里面没有任何成员变量和成员函数。对该类型求sizeof，得到的结果是多少？</p>
<p>答案：1</p>
<p>这个时候面试官肯定如果问你为什么不是0，我想不少同学就可能答不出来具体的原因了，当然这本书很好的讲解了这些基础原理。</p>
<p>原因：空类型的实例中不包含任何信息，本来求sizeof应该是0，但是当我们声明该类型的实例的时候，它必须在内存中占有一定的空间，否则无法使用这些实例。至于占用多少内存，由编译器决定。Visual Studio中每个空类型的实例占用1字节的空间。</p>
<p>问：如果在该类型中添加一个构造函数和析构函数，再对该类型求sizeof，得到的结果又是多少？</p>
<p>答：和前面一样，还是1。调用构造函数和析构函数只需要知道函数的地址即可，而这些函数的地址只与类型相关，而与类型的实例无关，编译器也不会因为这两个函数而在实例内添加任何额外的信息。</p>
<p>问：那如果把析构函数标记为虚函数呢？ 你看看，这题都是逐渐深入的。所以这是我推荐这本书的主要原因。</p>
<p>答：C++编译器一旦发现一个类型中有虚函数，就会为该类型生成虚函数表，并在该类型的每一个实例中添加一个虚函数表的指针。在32位的机器上，一个指针占4字节的空间，因此求sizeof得到4；如果是64位的机器，一个指针占8字节的空间，因此求sizeof则得到8。</p>
<p>2.分析以下程序的编译运行结果，3个选项：A.编译错误；B.编译成功，运行时程序崩溃；C.编译运行正常，输出10</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line"> <span class="keyword">int</span> value;</div><div class="line"><span class="keyword">public</span>:</div><div class="line"> A(<span class="keyword">int</span> n) {value = n;}</div><div class="line"> A(A other) {value = other.value;}</div><div class="line"> <span class="keyword">void</span> Print() {std::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; std::endl;}</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc,_TCHAR* argv[])</div><div class="line">{</div><div class="line"> A a = <span class="number">10</span>;</div><div class="line"> A b = a;</div><div class="line"> b.Print();</div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在上述代码中，复制构造函数A(A other)传入的参数是A的一个实例。由于是传值参数，我们把形参复制到实参会调用复制构造函数。因此如果允许复制构造函数传值，就会在复制构造函数内调用复制构造函数，就会形成永无休止的递归调用从而导致栈溢出。因此C++的标准不允许复制构造函数传值参数，在VS和GCC中，都将编译出错。要解决这个问题，我们可以把构造函数修改为A(const A&amp; other)，也就是把传值参数改成常量引用。</p>
<p>3.如下为类型CMyString的声明，请为该类型添加赋值运算符函数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class CMyString</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"> <span class="title">CMyString</span>(<span class="keyword">char</span>* pData = NULL);</div><div class="line"> CMyString(<span class="keyword">const</span> CMyString&amp; str);</div><div class="line"> ~CMyString(<span class="keyword">void</span>);</div><div class="line"><span class="keyword">private</span>:</div><div class="line"> <span class="keyword">char</span>* m_pData;</div><div class="line">};</div></pre></td></tr></table></figure>

<p>此题其实不是太难，但是此题书中的解题思路和考虑的问题让我叹服，这里把书中的观点表述下：<br>(1)是否把返回值的类型声明为该类型的引用，并在函数结束前返回实例自身的引用(即<em>this)。只有返回一个引用，才可以允许连续赋值。否则如果函数的返回值是void，应用该赋值运算符将不能做连续赋值。假设有3个CMyString的对象:str1、str2和str3，在程序中语句str1=str2=str3将不能通过编译。<br>(2)是否把传入的参数的类型声明为常量引用。如果传入的参数不是引用而是实例，那么从形参到实参会调用一次复制构造函数。把参数声明为引用可以避免这样的无谓消耗，能提高代码的效率。同时，我们在赋值运算符函数内不会改变传入的实例的状态，因此应该为传入的引用参数加上const关键字。<br>(3)是否释放实例自身已有的内存。如果我们忘记在分配内存之前释放自身已有的空间，程序将出现内存泄漏。<br>(4)是否判断传入的参数和当前的实例(</em>this)是不是同一个实例。如果是同一个，则不进行赋值操作，直接返回。如果事先不判断就进行赋值，那么在释放实例自身的内存的时候就会导致严重的问题：当*this和传入的参数是同一个实例时，那么一旦释放了自身的内存，传入的参数的内存也同时被释放了，因此再也找不到需要赋值的内容了。<br>经典的解法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">CMyString&amp; CMyString::<span class="keyword">operator</span> =(<span class="keyword">const</span> CMyString &amp;str)</div><div class="line">{</div><div class="line"> <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str)</div><div class="line"> <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line"></div><div class="line"><span class="keyword">delete</span> []m_pData;</div><div class="line"> m_pData = NULL;</div><div class="line"> m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>];</div><div class="line"> <span class="built_in">strcpy</span>(m_pData,str.m_pData);</div><div class="line"></div><div class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>考虑异常安全性的解法：<br>在前面的函数中，我们在分配内存之前先用delete释放了实例m_pData的内存。如果此时内存不足导致new char 抛出异常，m_pData将是一个空指针，这样非常容易导致程序崩溃。也就是说一旦在赋值运算符函数内部抛出一个异常，CMyString的实例不再保持有效的状态，这就违背了异常安全性(Exception Safety)原则。<br>要想在赋值运算符函数中实现异常安全性，我们有两种方法。一个简单的方式是我们先用new分配新内容再用delete释放已有的内存。这样只在分配内容成功之后再释放原来的内容，也就是当分配内存失败时我们能确保CMyString的实例不会被修改。我们还有一个更好的办法是先创建一个临时实例，再交换临时实例和原来的实例。下面是这种思路的参考代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">CMyString&amp; CMyString::operator =(<span class="keyword">const</span> CMyString &amp;<span class="keyword">str</span>)</div><div class="line">{</div><div class="line"> <span class="keyword">if</span>(this != &amp;<span class="keyword">str</span>)</div><div class="line"> {</div><div class="line"> CMyString strTemp(<span class="keyword">str</span>);</div><div class="line"> <span class="keyword">char</span>* pTemp = strTemp.m_pData;</div><div class="line"> strTemp.m_pData = m_pData;</div><div class="line"> m_pData = pTemp;</div><div class="line"> }</div><div class="line"> <span class="keyword">return</span> *this;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在这个函数中，我们先创建一个临时实例strTemp，接着把strTemp.m_pData和实例自身的m_pData做交换。由于strTemp是一个局部变量，但程序运行到if的外面时也就出了该变量的作用域，就会自动调用strTemp的析构函数，把strTemp.m_pData所指向的内存释放掉。由于strTemp.m_pData指向的内存就是实例之前m_pData的内存，这就相当于自动调用析构函数释放实例的内存。<br>在新的代码中，我们在CMyString的构造函数里用new分配内存。如果由于内存不足抛出诸如bad_alloc等异常，我们还没有修改原来实例的状态，因此实例的状态还是有效的，这也就保证了异常安全性。</p>
<p>参考资料：<br>《剑指offer》</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-08-25T14:58:28.000Z"><a href="/2013/08/25/linux-memory-and-manage/">8月 25 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/08/25/linux-memory-and-manage/">linux内存空间分配和内存管理</a></h1>
  

    </header>
    <div class="entry">
      
        <p>前段时间把《程序员的自我修养—链接、装载与库》这本书看完了，期间有些地方不是太明白，当时网络搜索了下，今天把当时看到的东西摘抄下，基本文中大部分内容都是拷贝下面提到的参考链接里的东西，自己在组织下，以备以后需要时查看。</p>
<p>地址分为三类，逻辑地址，线性地址和物理地址。</p>
<p>在《深入理解linux内核》中其把地址分为三类：逻辑地址（汇编语言中操作数地址或指令的地址，对于80x86的CPU，逻辑地址是段+段内偏移地址）、线性地址（也叫虚拟地址）和物理地址。但在Stott Maxwell的《Linux Core Kernel Commentrary》中确是这样分的：逻辑地址（也叫虚拟地址）、线性地址和物理地址。按照386CPU总设计师John Crowford的解释，虚拟地址是保护模式下段和段内偏移量组成的地址，而逻辑地址就是代码段内偏移量，或称进程的逻辑地址。其实对于linux来说，这三种说法都没错，由于linux下并不主张将程序分段，而是主张分页，所以即使是在80x86的体系结构下，段的基地址也是0。因此逻辑地址、线性地址、虚拟地址在linux中其实是相同的。所以对于linux下的ELF可执行文件来说，代码段的起始地址0x08048000既是逻辑地址，也是线性地址也是虚拟地址。</p>
<p>1.X86的物理地址空间布局</p>
<p><img src="http://armsword.com/wp-content/uploads/2013/08/201382501.jpg" alt=""></p>
<p>以x86_32，4G RAM为例：</p>
<p>物理地址空间的顶部以下一段空间，被PCI设备的I/O内存映射占据，它们的大小和布局由PCI(Peripheral Component Interconnect,一种连接电子计算机主板和外部设备的总线标准)规范所决定。640K~1M这段地址空间被BIOS和VGA(Video Graphics Array,视频传输标准)适配器所占据。</p>
<p>由于这两段地址空间的存在，导致相应的RAM空间不能被CPU所寻址(当CPU访问该段地址时，北桥会自动将目的物理地址“路由”到相应的I/O设备上，不会发送给RAM)，从而形成RAM空洞。</p>
<p>Linux内核是以物理页面(也称为PAGE FRAME)为单位管理物理内存的(X86机器中一个页面的大小默认为4KB)，为了方便的记录每个物理页面的信息，Linux定义了page结构体，位于include/linux/mm_types.h<br>Linux系统在初始化时，会根据实际的物理内存的大小，为每个物理页面创建一个page对象，所有的page对象构成一个mem_map数组。进一步，针对不同的用途，Linux内核将所有的物理页面划分到3类内存管理区中，如图，分别为ZONE_DMA，ZONE_NORMAL，ZONE_HIGHMEM。</p>
<p>ZONE_DMA的范围是0~16M，该区域的物理页面专门供I/O设备的DMA(Direct Memory Access，直接内存存取)使用。之所以需要单独管理DMA的物理页面，是因为DMA使用物理地址访问内存，不经过MMU，并且需要连续的缓冲区，所以为了能够提供物理上连续的缓冲区，必须从物理地址空间专门划分一段区域用于DMA。</p>
<p>ZONE_NORMAL的范围是16M~896M，该区域的物理页面是内核能够直接使用的。</p>
<p>ZONE_HIGHMEM的范围是896M~结束，该区域即为高端内存，内核不能直接使用。</p>
<p>2.linux虚拟地址内核空间分布</p>
<p><img src="http://armsword.com/wp-content/uploads/2013/08/20138250121.jpg" alt=""></p>
<p>在kernel image下面有16M的内核空间用于DMA操作。位于内核空间高端的128M地址主要由3部分组成，分别为vmalloc area，persistent kernel mapping(持久化内核映射区)，tempoary kernel mapping(临时内核映射区)。</p>
<p>由于ZONE<em>NORMAL和内核线性空间存在直接映射关系，所以内核会将频繁使用的数据如kernel代码、GDT、IDT、PGD、mem_map数组等放在ZONE_NORMAL里。而将用户数据、页表(PT)等不常用数据放在ZONE</em> HIGHMEM里，只在要访问这些数据时才建立映射关系(kmap())。比如，当内核要访问I/O设备存储空间时，就使用ioremap()将位于物理地址高端的mmio区内存映射到内核空间的vmalloc area中，在使用完之后便断开映射关系。</p>
<p>3.linux虚拟地址用户空间分布</p>
<p><img src="http://armsword.com/wp-content/uploads/2013/08/2013825013.jpg" alt=""></p>
<p>用户进程的代码区一般从虚拟地址空间的0x08048000开始，这是为了便于检查空指针。代码区之上便是数据区，未初始化数据区，堆区，栈区，以及参数、全局环境变量。</p>
<p>4.linux虚拟地址与物理地址映射的关系 [内核访问物理地址]</p>
<p><img src="http://armsword.com/wp-content/uploads/2013/08/2013825014.jpg" alt=""></p>
<p>Linux将4G的线性地址空间分为2部分，0~3G为user space，3G~4G为kernel space。</p>
<p>由于开启了分页机制，内核想要访问物理地址空间的话，必须先建立映射关系，然后通过虚拟地址来访问。为了能够访问所有的物理地址空间，就要将全部物理地址空间映射到1G的内核线性空间中，这显然不可能。于是，内核将0~896M的物理地址空间一对一映射到自己的线性地址空间中，这样它便可以随时访问ZONE_DMA和ZONE_NORMAL里的物理页面；此时内核剩下的128M线性地址空间不足以完全映射所有的ZONE_HIGHMEM，Linux采取了动态映射的方法，即按需的将ZONE_HIGHMEM里的物理页面映射到kernel space的最后128M线性地址空间里，使用完之后释放映射关系，以供其它物理页面映射。虽然这样存在效率的问题，但是内核毕竟可以正常的访问所有的物理地址空间了。</p>
<p>5.linux内存管理</p>
<p>Linux采用了分页的内存管理机制。由于x86体系的分页机制是基于分段机制的，因此，为了使用分页机制，分段机制是无法避免的。为了降低复杂性，Linux内核将所有段的基址都设为0，段限长设为4G，只是在段类型和段访问权限上有所区分，并且Linux内核和所有进程共享1个GDT(全局描述符表)，不使用LDT(局部描述符表即系统中所有的段描述符都保存在同一个GDT中)，这是为了应付CPU的分段机制所能做的最少工作。</p>
<p>Linux内存管理机制可以分为3个层次，从下而上依次为物理内存的管理、页表的管理、虚拟内存的管理。</p>
<p>当开启分段分页机制时，典型的x86寻址过程为：</p>
<p><img src="http://armsword.com/wp-content/uploads/2013/08/2013825015.png" alt=""></p>
<p>内存寻址的工作是由Linux内核和MMU共同完成的，其中Linux内核负责cr3，gdtr等寄存器的设置，页表的维护，页面的管理，MMU则进行具体的映射工作。</p>
<p>物理内存主要包括：物理页面分配和物理页面回收，当空闲物理页面不足时，就需要从inactive_clean_list队列中选择某些物理页面插入空闲队列中，如果仍然不足，就需要把某些物理页面里的内容写回到磁盘交换文件里，腾出物理页面。</p>
<p><img src="http://armsword.com/wp-content/uploads/2013/08/2013825016.jpg" alt=""></p>
<p>页表管理：</p>
<p>为了保持兼容性，Linux最多支持4级页表，而在x86上，实际只用了其中的2级页表，即PGD（页全局目录表）和PT(页表)，中间的PUD和PMD所占的位长都是0，因此对于x86的MMU是不可见的。</p>
<p><img src="http://armsword.com/wp-content/uploads/2013/08/2013825017.jpg" alt=""></p>
<p>6.linux中可执行程序与虚拟地址空间的映射关系</p>
<p>虚拟内存区域(VMA，Virtual Memory Area)是Linux中进程虚拟地址空间中的一个段，在Windows里面叫虚拟段。当操作系统创建线程后，会在进程相应的数据结构中设置一个.text段的VMA，它在虚拟空间中的地址为0x08048000~0x08049000，它对应ELF文件中的偏移为0的.text。由于linux下的ELF可执行文件会有很多个段(section)，所以如果把每个section都映射为一个VMA，那么没有一个页大小的段(section)也会被映射为一个页的VMA，这样就浪费了物理空间，由于不足会用0补充。故ELF有一个装载的段（segment)，与前面的段(section)不同，前面的段(section)主要用于链接，而段(segment)主要用于装载进内存。可以通过段（section）的权限来合并，如以代码段为代表的权限为可读可执行权限；以数据段和BSS段为代表的权限为可读可写的段；以只读数据为代表的权限为只读权限。</p>
<p>ELF与Linux进程虚拟空间映射关系如下：</p>
<p><img src="http://armsword.com/wp-content/uploads/2013/08/20130825018.jpg" alt=""></p>
<p>7.可执行文件的装载过程</p>
<p>一、进程的建立</p>
<p>(1)创建一个独立的虚拟地址空间</p>
<p>(2)读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系</p>
<p>(3)将CPU的指令寄存器设置成可执行文件的入口地址，启动运行。</p>
<p>二、页错误</p>
<p>上面的步骤执行完以后，其实可执行文件的真正指令和数据都没有载入到内存中。操作系统只是通过可执行文件头部的信息建立起可执行文件和进程虚存之间的映射关系而已。假设在上面的例子中，程序的入口地址为0X08048000，即刚好是.text段的起始地址。当CPU开始打算执行这个地址的指令时，发现0X08048000~0X08049000是个空白页，于是它就认为这是个页错误（Page Fault）。CPU将控制器交给操作系统，操作系统有专门的页错误处理例程来处理这种情况。这时候我们装载过程的第二步建立的数据结构起到了很关键的作用，操作系统将查询这个数据结构，然后找到空页面所在的VMA，计算出相应的页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，将进程中该虚拟页与分配的物理页之间建立映射关系，然后把控制权再还给进程，进程从刚才页错误的位置重新开始执行。随着进程的执行，页错误也会不断地产生，操作系统也会为进程分配相应的物理页面来满足进程执行的需求。当然有可能进程所需要的内存会超过可用的内存数量，特别是在有多个进程同时执行的时候，这时候操作系统就需要精心组织和分配物理内存，甚至有时候将分配给进程的物理内存暂时收回等等，这就涉及了操作系统的虚拟存储管理。</p>
<p><img src="http://armsword.com/wp-content/uploads/2013/08/20130825019.jpg" alt=""></p>
<p>参考资料：</p>
<p><a href="http://www.cnblogs.com/chengxuyuancc/archive/2013/04/17/3026920.html" target="_blank" rel="external">http://www.cnblogs.com/chengxuyuancc/archive/2013/04/17/3026920.html</a>（绝大部分拷贝此链接资料）</p>
<p><a href="http://www.cnblogs.com/zszmhd/archive/2012/08/29/2661461.html" target="_blank" rel="external">http://www.cnblogs.com/zszmhd/archive/2012/08/29/2661461.html</a></p>
<p>《程序员的自我修养—装载、链接与库》</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-08-25T08:21:02.000Z"><a href="/2013/08/25/linux-algrind-check-memory/">8月 25 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/08/25/linux-algrind-check-memory/">Linux下使用Valgrind做内存泄漏检查</a></h1>
  

    </header>
    <div class="entry">
      
        <p>在Windows下经常编程的同学肯定知道这款软件，Visual Leak Detector（VLD），这个是用于Visual C++的内存泄漏检测工具。同样，在Linux下也有一款与此功能相似的工具，它的名字叫做Valgrind。</p>
<p>Vlagrind是一款用来定位C/C++程序中内存使用方面的错误，它运行在Linux环境下，主要检测包括：内存泄漏、使用未初始化的内存、读/写已释放的内存、读/写内存越界、使用malloc/new/new[]和free/delete/delete[]不匹配，甚至可以检测死锁，竞争，还可以做性能分析等等。</p>
<p>Valgrind的官方网站下载地址：<a href="http://valgrind.org/downloads/current.html" target="_blank" rel="external">http://valgrind.org/downloads/current.html</a> ，安装时候直接 configure，make，make install 这些步骤就可以使用了。</p>
<p>使用方法：</p>
<p>用法: valgrind [valgrind-option] program [program-args]</p>
<p>-tool=&lt;name&gt; 最常用的选项，运行 valgrind中名为toolname的工具，默认memcheck。<br>-trace-children=no|yes 跟踪子线程<br>-track-fds=no|yes 跟踪打开的文件描述<br>-time-stamp=no|yes 增加时间戳到LOG信息<br>-log-file=&lt;file&gt; 将输出的信息写入到文件里</p>
<p>还有一些其他功能，我们现在用不到，就先不说了。那么具体的使用方法为：</p>
<p>结果输出到显示屏上：</p>
<p>valgrind —tool=memcheck —leak-check=full ./test</p>
<p>valgrind —leak-check=full —track-fds=yes ./test 程序参数  //省略了tool = memcheck</p>
<p>如果想把结果输出到日志文件上：</p>
<p>valgrind —log-file=valgrind_log —leak-check=full —track-fds=yes ./test 参数 (注意有二个 -)</p>
<p>检查内存错误要在上面的输出中看两个关键字：ERROR SUMMARY 和 LEAK SUMMARY。<br>```<br>==6135== Memcheck, a memory error detector<br>==6135== Copyright (C) 2002-2011, and GNU GPL’d, by Julian Seward et al.<br>==6135== Using Valgrind-3.7.0 and LibVEX; rerun with -h for copyright info<br>==6135== Command: ./findtopo<br>==6135== Parent PID: 5969<br>==6135==<br>==6135== Conditional jump or move depends on uninitialised value(s)<br>==6135== at 0x80497D6: handlesql (handlesql.c:34)<br>==6135== by 0x8049415: looptopo (looptopo.c:145)<br>==6135== by 0x8048E9E: main (findtopo.c:51)<br>Valgrind太强大了，搜索了下原理：valgrind在开始之前总会先取得对你的程序的控制权，从可执行关联库里读取调试信息。然后在valgrind核心提供的虚拟CPU上运行程序，valgrind会根据选择的工具来处理代码，该工具会向代码中加入检测代码，并把这些代码作为最终代码返回给valgrind核心，最后valgrind核心运行这些代码。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-08-04T07:22:57.000Z"><a href="/2013/08/04/redis-source/">8月 4 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/08/04/redis-source/">准备看下Redis的源代码</a></h1>
  

    </header>
    <div class="entry">
      
        <p>Redis是一个开源，BSD授权，高性能的key-value数据库，使用ANSI C编写。Redis的出现很大程度补偿了memcached这类key-value存储的不足，因为：</p>
<p>Memcached基本只支持简单的key-value存储，不支持枚举，不支持持久化和复制能功能。</p>
<p>Redis除key-value之外，还支持list,set,sorted set,hash等众多数据结构，提供了KEYS进行枚举操作，但不能在线上使用，如果需要枚举线上数据，Redis提供了工具可以直接扫描其dump文件，枚举出所有数据，Redis还同时提供了持久化和复制等功能。</p>
<p>如果简单地比较Redis与Memcached的区别，大多数都会得到以下观点：</p>
<ul>
<li>Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份。</li>
<li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。<br>Redis和memcached不同之处还在以下方面：1.网络IO模型 2.内存管理方面 3.数据一致性问题 4.存储方式及其它方面（上文提到了）等等，这里不在细说。</li>
</ul>
<p>数据模型：</p>
<p>Redis 的外围由一个键、值映射的字典构成。与其他非关系型数据库主要不同在于：Redis 中值的类型不仅限于字符串，还支持如下抽象数据类型：<br>1.字符串列表<br>2.无序不重复的字符串集合<br>3.有序不重复的字符串集合<br>4.键、值都为字符串的哈希表<br>值的类型决定了值本身支持的操作。Redis 支持不同无序、有序的列表，无序、有序的集合间的交集、并集等高级服务器端原子操作。</p>
<p>持久化：</p>
<p>Redis 通常将全部的数据存储在内存中。2.4版本后可配置为使用虚拟内存，一部分数据集存储在硬盘上，但这个特性废弃了。<br>目前通过两种方式实现持久化：<br>使用快照，一种半持久耐用模式。不时的将数据集以异步方式从内存以 RDB 格式写入硬盘。<br>1.1版本开始使用更安全的 AOF 格式替代，一种只能追加的日志类型。将数据集修改操作记录起来。Redis 能够在后台对只可追加的记录作修改来避免无限增长的日志。</p>
<p>同步：</p>
<p>Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得 Redis 可执行单层树复制。从盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。</p>
<p>性能：</p>
<p>当数据依赖不再需要，Redis 这种基于内存的性质，与在执行一个事务时将每个变化都写入硬盘的数据库系统相比就显得执行效率非常高。写与读操作速度没有明显差别。</p>
<p>上面东西，是从维基百科摘抄下来的，只是更好的了解此数据库。关于源码解读，发现有热心网友专门写了源码剖析，见下面链接：</p>
<p><a href="http://www.redisbook.com/en/latest/" target="_blank" rel="external">Redis设计与实现</a></p>
<p>打算边看源码边看下此剖析。</p>
<h1 id="Installation">Installation</h1>
<p>Download, extract and compile Redis with:<br><code>$ wget http://redis.googlecode.com/files/redis-2.6.14.tar.gz
$ tar xzf redis-2.6.14.tar.gz
$ cd redis-2.6.14
$ make</code><br>The binaries that are now compiled are available in the <code>src</code> directory. Run Redis with:<br>$ src/redis-server</p>
<p>You can interact with Redis using the built-in client:<br><code>$ src/redis-cli
redis&amp;gt; set foo bar
OK
redis&amp;gt; get foo
&quot;bar&quot;</code></p>
<p>tutorial:<br><a href="http://try.redis.io/" target="_blank" rel="external">http://try.redis.io/</a></p>
<p>参考连接：</p>
<p><a href="http://zh.wikipedia.org/wiki/Redis" target="_blank" rel="external">http://zh.wikipedia.org/wiki/Redis</a></p>
<p><a href="http://www.redis.io/" target="_blank" rel="external">http://www.redis.io/</a></p>
<p><a href="http://simple-is-better.com/news/684" target="_blank" rel="external">http://simple-is-better.com/news/684</a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-08-02T13:43:41.000Z"><a href="/2013/08/02/understand-about-tcp-ip/">8月 2 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/08/02/understand-about-tcp-ip/">记录下TCP/IP协议的一些知识点</a></h1>
  

    </header>
    <div class="entry">
      
        <p>1.bind的功能是将本地地址和端口绑定到套接字上去。</p>
<p>2.int listen(SOCKET s,int backlog); 参数backlog是挂起连接的最大数量，它并不是在指定端口上同时可建立连接的最大值，而是排队等待应用程序接受的连接或部分连接的最大数量。</p>
<p>它唯一的任务就是把套接字标识为监听状态，当主机收到一个连接请求时，内核会搜索监听套接字列表，查找与连接请求中目的地和端口号相匹配的那个套接字。</p>
<p>3.connect的作用之一就是将远程实体的地址和端口绑定到本地套接字上去。</p>
<p>4.accept负责接受已完成连接队列中的连接。</p>
<p>5.典型的面向连接协议有三个阶段：</p>
<p>(1)在对等实体间建立连接</p>
<p>(2)数据传输阶段，数据在对等实体间传输</p>
<p>(3)当对等实体完成数据传输，连接被拆除</p>
<p>6.为了提供可靠性，TCP向基本的IP服务中添加了三项功能。首先，它为TCP段中的数据提供了校验和，这样有助于确保抵达目的地的数据在传输过程中不会被网络损坏。第二，它为每字节分配了一个序列号，这样如果数据抵达目的地时真的错序了，接收端也能够按照恰当的顺序将其重装起来。第三，TCP提供了一种确认-重传机制，以确保最终每个段都会被传送出去。</p>
<p>7.UDP只向底层的IP协议中添加了两项功能。首先，它提供了一个可选的校验和来检测数据的损坏情况。尽管IP也有校验和，但它只对IP分组首部进行计算，所以，TCP和UDP也都提供了校验和来保护它们自己的首部和数据。UDP向IP添加的第二特征是端口的概念。</p>
<p>分组到达时，内核会搜索其套接字列表，查找一个与组中的协议地址和端口号相匹配的套接字，如果找到了匹配的套接字，就由指定的协议来处理数据，并将这些数据提供给所有打开了匹配套接字的应用程序。</p>
<p>8.TCP是一种流协议(stream dream)，这就意味着数据是以字节流的形式传递给接收者的，没有固定的“报文”或“报文边界”的概念，从这方面来说，读取TCP数据就像从串行端口读取数据一样——&gt;无法预先得知在一次指定的读调用中会返回多少字节。由TCP来决定需要立即发送多少数据，做这种决定的过程很复杂，取决于很多因素，比如发送窗口（当时主机能够接收的数据量），拥塞窗口（对网络拥塞的估计），路径上的最大传输单元（沿着主机之间的网络路径一次可以传输最大的数据量），以及连接的输出队列中有多少数据。</p>
<p>TCP会记录它发送了多少字节，以及确认的字节，但它不会记录这些字节是如何分组的，实际上，有些实现在重传丢失分组的时候发送的数据可能比原来的多一些或少一些。TCP的手段主要有校验和、序列号、确认应答、重发控制、连接管理、窗口控制等。</p>
<p>9.TCP是一个复杂的协议，在基本IP数据报服务的基础上添加了可靠性的流量控制功能，而UDP只添加了一个校验和，所以UDP可能要比TCP快一个数量级或更多。</p>
<p>10.以太网帧最多可以装载1500B的数据，IP和TCP首部各需要20B，剩下1460B，为TCP选项另外保留20B。</p>
<p>11.LAN提供的近乎理想的环境可以掩盖网络应用程序的性能问题，甚至是错误。记住，一个在LAN上运行良好的应用程序在WAN上很可能就会出问题。WAN上时延的增加会让在LAN上性能良好的应用程序在WAN上的性能不尽如意。</p>
<p>12.TCP发送策略的主要目标之一是尽可能有效地利用可用带宽，如果只考虑这些问题，发送策略就很简单：根据发送窗口允许的最大值，以长度为MSS的段将所有可用的数据都发送出去。但是，我们还需要考虑其他一些与之冲突的情况。</p>
<p>首先，拥塞控制就是一个非常重要的问题，如果TCP突然要将大量TCP段传入网络中去，路由缓冲区空间会被耗尽，造成数据报的丢失。为了避免出现拥塞，TCP不会突然同时向空闲连接上发送多个段，相反，开始它会发送一个段，然后增加网络中未经确认的段的数量，直到达到一个稳定状态为止。TCP使用了两种算法来防止拥塞，一个是慢启动算法，另一个是Nagle算法。</p>
<p>13.TCP的写操作，从应用程序的角度来看，最好把写操作当作是一项将数据从用户空间复制到内核发送缓冲区，然后就返回的操作，实际上TCP会在什么时候传送数据，以及会立即传送多少数据出去，都取决于连接的状态，而且通常应用程序都是无法预测的。</p>
<p>14.直到最近，大家普遍认为由于WinSock和基本上所有现代的UNIX系统都支持select，所以考虑到可移植性，应当选择select而不是poll，而poll则大多用于SysV实现中。但一些支持多条同步连接的大型服务区应用程序（比如Web服务器）却在使用poll机制，因此它能更好地使用使用大量描述符的情况。这是因为select只能局限于固定数量的描述符，限制通常是1024，但可能会更小，修改默认值需要重构内核。</p>
<p>15.可以设置套接字选项SO_REUSEADDR，指示TCP允许我们绑定到一个已经在使用的端口上。</p>
<p>16.使connect调用超时的方式是使套接字成为阻塞的，然后用select等待它完成。</p>
<p>17.每个IP数据报都有TTL字段，每经过一个路由器，该字段就被减1，抵达路由器的数据报的TTL为1或0时，就会被丢弃，同时会发送一个ICMP“传输超时”错误报文给原始发送者。traceroute利用了这个特性，它首先向目的地发送一个TTL设置为1的UDP数据报。当这个UDP数据报抵达第一跳时，路由器注意到TTL为1，就会将其丢弃，并发回一个ICMP报文，从这个ICMP报文的源地址中，可以得到第一跳的IP地址，然后traceroute用gethostbyaddr来查询它的名字。为获得下一跳的标识，traceroute重复这个过程，只是把TTL设置为2，当这个数据报到达第一跳时，TTL被减为1并转发往下一跳，在那里发现TTL为1，丢弃它，并返回ICMP报文，通过不断增加TTL来重复这个过程，traceroute就可以获得从源到目的地之间的路径消息。</p>
<p>18.lsof -i TCP:6000 （查看哪个进程正在监听这个端口）</p>
<p>lsof -i @armsword.com （查看哪个用户在连接）</p>
<p>19.netstat 默认情况下，绑定在INADDR_ANY的服务器的套接字是不列出来的，不过可以用 -a 选项改变默认设置。</p>
<p>netstat -i （接口）  netstat -rn （路由表）</p>
<p>netstat -sp udp （获取关于UDP的统计信息）</p>
<p>参考资料：</p>
<p>《TCP/IP高效编程》</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-07-02T08:00:35.000Z"><a href="/2013/07/02/makefile/">7月 2 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/07/02/makefile/">Makefile学习笔记</a></h1>
  

    </header>
    <div class="entry">
      
        <p>第一次用Makefile，看了一些开源的源代码的Makefile，又看了下规则，之后把自己的小程序写了个Makefile，总结下笔记。</p>
<p>Makefile的编写规则：</p>
<p>（1）如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。</p>
<p>（2）如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。</p>
<p>（3）如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。</p>
<p>target … : prerequisites …</p>
<p>command</p>
<p>…</p>
<p>…</p>
<p>target也就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。</p>
<p>prerequisites就是，要生成那个target所需要的文件或是目标。</p>
<p>command也就是make需要执行的命令，TAB键。（任意的Shell命令）</p>
<pre><code><span class="type">INCLUDE</span> = ./include

<span class="type">INCLUDE</span> += -<span class="type">I</span>/usr/include/mysql

objects = findtopo.o looptopo.o handlesql.o readoid.o ifroute.o

  ifirewall.o hostname.o

findtopo : $(objects)

  gcc -o findtopo $(objects) -lsnmp -lmysqlclient

findtopo.o : findtopo.<span class="built_in">c</span> findtopo.h

  gcc -<span class="built_in">c</span> findtopo.<span class="built_in">c</span> $&amp;lt; -<span class="type">I</span>$(<span class="type">INCLUDE</span>)

looptopo.o : looptopo.<span class="built_in">c</span> findtopo.h

  gcc -<span class="built_in">c</span> looptopo.<span class="built_in">c</span> $&amp;lt; -<span class="type">I</span>$(<span class="type">INCLUDE</span>)

handlesql.o : handlesql.<span class="built_in">c</span> findtopo.h

  gcc -<span class="built_in">c</span> handlesql.<span class="built_in">c</span> $&amp;lt; -<span class="type">I</span>$(<span class="type">INCLUDE</span>)

readoid.o : readoid.<span class="built_in">c</span> findtopo.h

  gcc -<span class="built_in">c</span> readoid.<span class="built_in">c</span> $&amp;lt; -<span class="type">I</span>$(<span class="type">INCLUDE</span>)

ifroute.o : ifroute.<span class="built_in">c</span> findtopo.h

  gcc -<span class="built_in">c</span> ifroute.<span class="built_in">c</span> $&amp;lt; -<span class="type">I</span>$(<span class="type">INCLUDE</span>)

ifirewall.o : ifirewall.<span class="built_in">c</span> findtopo.h

  gcc -<span class="built_in">c</span> ifirewall.<span class="built_in">c</span> $&amp;lt; -<span class="type">I</span>$(<span class="type">INCLUDE</span>)

hostname.o : hostname.<span class="built_in">c</span> findtopo.h

  gcc -<span class="built_in">c</span> hostname.<span class="type">C</span> $&amp;lt; -<span class="type">I</span>$(<span class="type">INCLUDE</span>)

.<span class="type">PHONY</span> : clean

clean:

  rm findtopo findtopo.o looptopo.o handlesql.o readoid.o

ifroute.o ifirewall.o hostname.o
</code></pre><p>“$&lt;”表示所有的依赖目标集，.PHONY意思表示clean是一个“伪目标”。向make说明，不管是否有这个文件，这个目标就是“伪目标”。</p>
<p>.PHONY : clean</p>
<p>只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有“make clean”这样。</p>
<p>make是如何工作的</p>
<p>在默认的方式下，也就是我们只输入make命令。那么，</p>
<p>1、make会在当前目录下找名字叫“Makefile”或“makefile”的文件。</p>
<p>2、如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“findtopo”这个文件，并把这个文件作为最终的目标文件。</p>
<p>3、如果findtopo文件不存在，或是findtopo所依赖的后面的 .o 文件的文件修改时间要比findtopo这个文件新，那么，它就会执行后面所定义的命令来生成findtopo这个文件。</p>
<p>4、如果findtopo所依赖的.o文件也存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。</p>
<p>5、当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件生命make的终极任务，也就是执行文件findtopo了。</p>
<p>参考文献：</p>
<p>《跟我一起写Makefile》</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-06-24T02:12:08.000Z"><a href="/2013/06/24/use-snmp-find-topo/">6月 24 2013</a></time>
      
      
  
    <h1 class="title"><a href="/2013/06/24/use-snmp-find-topo/">利用SNMP发现网络拓扑信息</a></h1>
  

    </header>
    <div class="entry">
      
        <p>看了一些资料包括一些论文，没发现特别好的方法，并且我发现很多论文里面竟然还有错误。不过总体思路就是利用SNMP查询获取MIB管理信息库。那有什么办法区分网络里面的路由器、防火墙还有交换机呢？</p>
<p>其实，我认为这个很难区分，传统的路由器应该属于网络层，交换机属于数据链路层，但是现在的路由器包含交换机，交换机也都有三层、四次交换机并且包括路由功能，所以，很难完全区分开来。</p>
<p>传统的方法是这样的：</p>
<p>通过SNMP协议（我用的开源的net-snmp库）获取网络设备MIB中的ipForwarding（OID：.1.3.6.1.2.1.4.1.0）对象值，如果该值为1，就表示此硬件为路由器。如果该值为2，则进一步获取MIB中的sysServices（OID：.1.3.6.1.2.1.1.7.0）对象值，如果该值为78，说明网络设备工作在链路层，类型为交换机，如果该值为76（实际我测试结果为6），说明网络设备没有工作在链路层，类型为个人计算机。查询ipRouteType（OID：.1.3.6.1.2.1.4.21.1.8）字段的值，若该值为3（direct）表明为直接路由，若该值为4（indirect）则为间接路由。</p>
<p>但是，我实际测试的时候是这样的：</p>
<p>当sysSerices为78时确实为路由器，但是4也是路由器（即判断syservices为78或4），6为交换机（即判断sysService为76或6），但是当硬件为防火墙或主机时候，sysServices可能为空也可能为72，所以，这个是无法分辨出其到底为防火墙还是主机。并且，ipForwarding的值无论是路由还是防火墙其值都为1，注意主机的MIB下的IP是无值的，因为此处是一些路由信息。对于此问题，我是用这种方法解决的：</p>
<p>因为一个网络里面，防火墙的品牌毕竟是有限的，其实多说也就几种，所以我们可以查询sysName（OID：.1.3.6.1.2.1.1.5.0）来辨别是不是指定的值（主机的值与其值相同的概率肯定会非常低吧^_^），比如当sysName的值为“TopsesOS”时，其就是天融信防火墙。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



<nav id="pagination">
  
    <a href="/page/5/" class="alignleft prev">上一页</a>
  
  
    <a href="/page/7/" class="alignright next">下一页</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:armsword.com">
  </form>
</div>


  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/C-C/">C/C++</a><small>23</small></li>
  
    <li><a href="/categories/Database/">Database</a><small>2</small></li>
  
    <li><a href="/categories/Linux/">Linux</a><small>14</small></li>
  
    <li><a href="/categories/ML-NLP/">ML/NLP</a><small>3</small></li>
  
    <li><a href="/categories/Web-Script/">Web/Script</a><small>4</small></li>
  
    <li><a href="/categories/Windows/">Windows</a><small>3</small></li>
  
    <li><a href="/categories/我的生活/">我的生活</a><small>3</small></li>
  
    <li><a href="/categories/算法-数据结构/">算法/数据结构</a><small>4</small></li>
  
    <li><a href="/categories/计算机网络/">计算机网络</a><small>8</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2015/01/31/baidu-lossless-music-downloader/">写了一个Chrome插件 - 百度无损音乐下载插件</a>
      </li>
    
      <li>
        <a href="/2015/01/26/jwsmtp-analyse/">jwSMTP源码剖析</a>
      </li>
    
      <li>
        <a href="/2014/12/01/learn-emacs-note/">Emacs学习笔记</a>
      </li>
    
      <li>
        <a href="/2014/11/22/move-from-wordpress-to-hexo/">将WordPress迁移到hexo并同时托管到Github和Gitcafe上</a>
      </li>
    
      <li>
        <a href="/2014/11/07/finding-job-result/">一蓑烟雨任平生</a>
      </li>
    
      <li>
        <a href="/2014/10/29/tinyhttpd-code-analyse/">tinyhttpd源码剖析</a>
      </li>
    
      <li>
        <a href="/2014/10/26/webbench-source-analyse/">Webbench源码剖析</a>
      </li>
    
  </ul>
</div>



  

  <div class="widget tag">
<h3 class="title">友情链接</h3>
<ul class="entry">
<li><a href="http://linuxer.me" target="_blank" title="armsword的涅槃之地">armsword</a></li>
<li><a href="http://yanyiwu.com" target="_blank" title="YanYi">YanYi</a></li>
<li><a href="http://dreamshield.net/" target="_blank" title="DreamShield">DreamShield</a></li>
<li><a href="http://blog.purplecow.me" target="_blank" title="PurpleCow">PurpleCow</a></li>
<li><a href="http://cstdlib.com" target="_blank" title="徐小夫">徐小夫</a></li>
</ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft"> 
  
  &copy; 2015 armsword
  
  || 
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253622272'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s95.cnzz.com/z_stat.php%3Fid%3D1253622272' type='text/javascript'%3E%3C/script%3E"));</script>

 
</div>
<div class="clearfix"></div>
</footer>
  <script src="/js/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id="totop" style="position:fixed;bottom:30px;right:30px;cursor: pointer;">
<a title="返回顶部"><img src="/imgs/scrollup.png"/></a>
</div>

<script src="/js/totop.js"></script>


</body>
</html>